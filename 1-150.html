<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>“主要的编程范型”及其语言特性关系（多图）</title>

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="/favicon.png">
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />
    <!-- <link rel="stylesheet" type="text/css" href="//fonts.useso.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" /> -->
    <link rel="stylesheet" type="text/css" href="/assets/plugins/font-awesome-4.5.0/css/font-awesome.min.css" />
    <link rel="stylesheet" type="text/css" href="/assets/plugins/bootstrap-3.3.5/css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="/assets/plugins/highlight-9.1.0/styles/xcode.css" />
    <link rel="stylesheet" type="text/css" href="/assets/plugins/anijs-0.9.3/anicollection.min.css" />
    <link rel="stylesheet" type="text/css" href="/assets/plugins/fancybox-2.1.5/jquery.fancybox.css" />
    <link rel="shortcut icon" href="/favicon.png" type="image/png" />
    <meta name="referrer" content="no-referrer-when-downgrade" />
    
    <meta property="og:site_name" content="Aimingoo&#x27;s Blog" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="“主要的编程范型”及其语言特性关系（多图）" />
    <meta property="og:description" content="“主要的编程范型”(The principal programming paradigms)这幅图，其实出现得不算早，作者在2007年完成了该图的1.0版，到2008年更新至v1.08版本。本次提供的是翻译成中文的版本（老实说，笔者翻译水平相当有限，若有不当之处，请各位尽量指出，必尽快补正）。 这幅图的原作者Peter Van Roy，是《Concepts, Techniques, and Models of Computer Programming》一书的作者，这本书(CTM)是少有的、能跟SICP并称的书了。 该图原文档(PDF)下载：http://www.info.ucl.ac.be/~pvr/paradigmsDIAGRAMeng108.pdf 该图中文翻译文件(PDF)下载在这里。 （图1）主要的编程范型(" />
    <meta property="og:url" content="https://aimingoo.github.io/1-150.html" />
    <meta property="article:published_time" content="2009-10-09T20:31:00.000Z" />
    <meta property="article:modified_time" content="2017-06-15T21:03:22.000Z" />
    <meta property="article:tag" content="语言" />
    <meta property="article:tag" content="编程" />
    
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="“主要的编程范型”及其语言特性关系（多图）" />
    <meta name="twitter:description" content="“主要的编程范型”(The principal programming paradigms)这幅图，其实出现得不算早，作者在2007年完成了该图的1.0版，到2008年更新至v1.08版本。本次提供的是翻译成中文的版本（老实说，笔者翻译水平相当有限，若有不当之处，请各位尽量指出，必尽快补正）。 这幅图的原作者Peter Van Roy，是《Concepts, Techniques, and Models of Computer Programming》一书的作者，这本书(CTM)是少有的、能跟SICP并称的书了。 该图原文档(PDF)下载：http://www.info.ucl.ac.be/~pvr/paradigmsDIAGRAMeng108.pdf 该图中文翻译文件(PDF)下载在这里。 （图1）主要的编程范型(" />
    <meta name="twitter:url" content="https://aimingoo.github.io/1-150.html" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="aimingoo" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="语言, 编程" />
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "Aimingoo&#x27;s Blog",
        "logo": "https://aimingoo.github.io/content/images/2017/05/-----2017-05-06-12-31-48.png"
    },
    "author": {
        "@type": "Person",
        "name": "aimingoo",
        "image": {
            "@type": "ImageObject",
            "url": "https://aimingoo.github.io/content/images/2017/10/IMG_5559-1.jpg",
            "width": 128,
            "height": 128
        },
        "url": "https://aimingoo.github.io/author/aimingoo/",
        "sameAs": []
    },
    "headline": "“主要的编程范型”及其语言特性关系（多图）",
    "url": "https://aimingoo.github.io/1-150.html",
    "datePublished": "2009-10-09T20:31:00.000Z",
    "dateModified": "2017-06-15T21:03:22.000Z",
    "keywords": "语言, 编程",
    "description": "“主要的编程范型”(The principal programming paradigms)这幅图，其实出现得不算早，作者在2007年完成了该图的1.0版，到2008年更新至v1.08版本。本次提供的是翻译成中文的版本（老实说，笔者翻译水平相当有限，若有不当之处，请各位尽量指出，必尽快补正）。 这幅图的原作者Peter Van Roy，是《Concepts, Techniques, and Models of Computer Programming》一书的作者，这本书(CTM)是少有的、能跟SICP并称的书了。 该图原文档(PDF)下载：http://www.info.ucl.ac.be/~pvr/paradigmsDIAGRAMeng108.pdf 该图中文翻译文件(PDF)下载在这里。 （图1）主要的编程范型(",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://aimingoo.github.io/"
    }
}
    </script>

    <script type="text/javascript" src="/public/ghost-sdk.min.js"></script>
<script type="text/javascript">
ghost.init({
	clientId: "ghost-frontend",
	clientSecret: "e8bc7646b93e"
});
</script>
    <meta name="generator" content="Ghost 1.14" />
    <link rel="alternate" type="application/rss+xml" title="Aimingoo&#x27;s Blog" href="https://aimingoo.github.io/rss/" />
</head>

<body class="post-template tag-yu-yan tag-bian-cheng nav-closed" data-spy="scroll" data-target="#tocScrollspy">

    <div class="site-wrapper">

        


<header class="main-header">
    <nav class="container main-nav clearfix">
        <div class="main-nav-title pull-left">
            <script>
            var titleTextInBody = '<a class="blog-title" href="https://aimingoo.github.io">Aimingoo&#x27;s Blog</a>';
            var theAuthor = {slug: 'aimingoo', url: '/author/aimingoo/'};
            if (theAuthor.slug == 'joyxhy') {
                titleTextInBody = '<' + 'a class="blog-title" hr' + 'ef="' + theAuthor.url + '">麦秸的垛</a>';
            }
            document.writeln(titleTextInBody);
            </script>
        </div>
            <div class="nav pull-right">
    <ul>
            <li class="nav-" role="presentation"><a href="https://aimingoo.github.io/">首页</a></li>
            <li class="nav-" role="presentation"><a href="https://aimingoo.github.io/author/joyxhy/">麦秸的垛</a></li>
            <li class="nav-" role="presentation"><a href="https://aimingoo.github.io/archives-post/">历史</a></li>
            <li class="nav-" role="presentation"><a href="https://aimingoo.github.io/about/">关于</a></li>
    </ul>
</div>

    </nav>
</header>

<script type="text/javascript" author="aimingoo" src="/assets/js/author-switcher.js"></script>

<main id="container" class="container" role="main">
    <div id="content" class="content col-sm-12 col-md-8 col-lg-8">
        <article class="post tag-yu-yan tag-bian-cheng">
            <header class="post-header">
                <h1 class="post-title u-aimingoo"><a href="/1-150.html">“主要的编程范型”及其语言特性关系（多图）</a></h1>
                <section class="post-meta">
                    <span class="post-meta-item">
                        <i class="fa fa-user"></i>
                        <a href="/author/aimingoo/">aimingoo</a>
                    </span>
                    <span class="post-meta-item">
                        <i class="fa fa-clock-o"></i>
                        <time class="post-date" datetime="2009-10-10T04:31:00.000+08:00" timeago="true"></time>
                        <time class="post-date" datetime="2009-10-10">(2009-10-10)</time>
                    </span>
                    <span class="post-meta-item post-meta-tags">
                        <i class="fa fa-tag"></i>
                        <a href="/tag/yu-yan/">语言</a>, <a href="/tag/bian-cheng/">编程</a>
                    </span>
                    <span class="post-meta-item pull-right">
                        
                    </span>
                </section>
            </header>

            <section class="post-content">
                <div class="kg-card-markdown"><p>“主要的编程范型”(The principal programming paradigms)这幅图，其实出现得不算早，作者在2007年完成了该图的1.0版，到2008年更新至v1.08版本。本次提供的是翻译成中文的版本（老实说，笔者翻译水平相当有限，若有不当之处，请各位尽量指出，必尽快补正）。</p>
<p>这幅图的原作者Peter Van Roy，是《Concepts, Techniques, and Models of Computer Programming》一书的作者，这本书(CTM)是少有的、能跟SICP并称的书了。</p>
<blockquote>
<ul>
<li>
<p>该图原文档(PDF)下载：<a href="http://www.info.ucl.ac.be/~pvr/paradigmsDIAGRAMeng108.pdf">http://www.info.ucl.ac.be/~pvr/paradigmsDIAGRAMeng108.pdf</a></p>
</li>
<li>
<p>该图中文翻译文件(PDF)下载<a href="/content/images/attachments/paradigmsDIAGRAMeng108_CN.zip">在这里</a>。</p>
</li>
</ul>
</blockquote>
<p><a href="/content/images/paradigmsDIAGRAMeng108_CN.png"><img src="/content/images/bkImages/1804_1318005992tQDq-9.jpg" alt="主要的编程范型"></a></p>
<p><strong>（图1）主要的编程范型(点击查看大图)</strong></p>
<h2 id="">一、从数据到编程</h2>
<p>Peter在“主要的编程范型”中，首先分清了数据描述语言与描述式编程语言。他把数据描述语言——例如XML——作为独立部分划分出来，然后指出这类语言主要考虑数据结构的描象，理论上基于人们对结构（记录/Record、结构/Struct）的理解。接下来，作者在此基础上引入第一种“程序设计特性”，即procedure，由此得到“初阶函数式编程”这一个基本的程序设计范型。</p>
<p>从这里可见Peter在程序设计语言分类上与以前的其它方法的不同之处：Peter并不在乎语言出现的时间关系，也不在乎语言的流行程度的影响。他着力于观察语言特性发展之间的脉络。而必须要对上述内容补充说明的是，Peter在“初阶函数式编程”所说的函数，事实上是早期业界对“函数(function)”的定义，即：例程分为过程、函数两种，二者区别仅在于前者不返回值，后者返回值。所以事实上，在这里Peter强调的是一种“普通例程”的特性。</p>
<h2 id="cellsstate">二、最重要的分类依据：cells(state)</h2>
<p>接下来，Peter将一个最重要的概念&quot;state&quot;引入进来。而这个state也是Peter对语言进行分类并考察它们的进化变化的主要依据。但是，Peter所引用的这个state概念，以及在这里使用的专用名词“cells”相当地令人迷惑，所以在这个图的补充说明中，Peter对此专门做了解释：“状态是记忆信息的一种能力，更精确地说，是及时存贮值序列的能力。”</p>
<p>你觉得这个概念象什么？对了，的确，非常象是“变量”。事实上，状态在编程核心概念的“数据-逻辑”抽象中，它表明的正是“数据的可变性”，亦即是说：数据的可变性表现为状态。更进一步地说：当数据被命名时，它称为变量或常量；当数据未命名时，它成为游离的、无名称和时序含义的存储单元，即“cells”。这也是Peter使用“cells”这个专用名词的原因：在本图的讨论中，需要从“变量/常量”这样的概念中，剥离掉“未命名或命名的、确定的或非确定的，以及串行的或并发的”这三方面的性质。</p>
<p>当不考虑一个存储位置上的命名特性时，它就既非变量、常量，也非某个确定的运算对象（例如“对象”等高级的抽象概念），而只是一种更加泛义的“状态”，而存储这个状态本身的，则因为没有位置、时序等概念，而称为“cells”。</p>
<h2 id="">三、命令式语言的诞生：状态维护</h2>
<p>《程序设计语言》这本书解释过命令式语言的本质特性，即：用算法改变数据。如果用两个以上的逻辑（例如两行代码）去影响同一个存储位置(cells)，并使它的状态改变，最终在该cell产生运算结果的，那么它就是一种命令式语言。</p>
<p>再简单一点（但没有上面这样严谨）地说：在程序中不断地重写变量，变量值即是程序的最终结果。</p>
<p>所以，在本图中，Peter把这个衍生关系表达为：命令式=纯数据+算法+状态维护。如图：</p>
<p><img src="/content/images/bkImages/1804_1318005604Fq3y-9.png" alt="命令式语言的诞生"></p>
<p><strong>（图2）命令式语言的诞生</strong></p>
<h2 id="">四、在命令式编程中对“状态”的理解：共享状态</h2>
<p>无论是在串行的，还是并发的编程中，命令式编程范型对“状态”的理解都是：共享状态。在图中，这一分支表现为全部的桃红色（参见后图）。</p>
<p>在串行（例如单线程）的编程中，状态是时序相关的。因为不断地重写“状态（数据/cells/变量）”，所以前一行和后一行所面对都是同一个共享状态的不同的值/副本。在这个过程中，状态是时序相关的，所以前一分钟与后一分钟的状态是不确定的——但是在同一时刻，这个状态是确定的。</p>
<p>与上面类似的，在多线程中，同一时刻，不同线程也将面临这个值/副本。但是正是因为多线程（并发）中，线程A与线程B对于同一个cell，在同一时刻所得到的状态也是不确定的——我们可以假想为多核CPU在对同一个内存地址读写（于是就出现了我们所谓的“同步”问题，进而也就出现了“锁”的问题），所以在这个分支中，当加入“线程”概念之后，新的编程范型，全都变成了“观测-非确定性”为“yes”的情况。</p>
<p><img src="/content/images/bkImages/1804_1318005615WWFg-9.png" alt="非确定性"></p>
<p><strong>（图3）观测-非确定性（留意图中加粗的黑框），以及状态的共享</strong></p>
<p>“观测-非确定性(Observable nondeterminism)”可以被译为“测不准”，但是用在中文中依然拗口，所以我选择了直译。在Peter的书(CTM)中，对该问题有一个经典的示例，即：</p>
<pre><code>declare
  C = {NewCell 0}

thread
  C:=1
end

thread
  C:=2
end
</code></pre>
<p>Peter这段代码的意思是说：当线程1和线程2，在同时向C这个cell写数据时，你并不确知上述代码运行之后C这个位置上的值究竟是1，还是2。</p>
<h2 id="cell">五、解决这个问题的终极之道：不要写cell！</h2>
<p>我们显然发现，问题是因为多个线程都在“写cell”。在命令式的解决方案中，采用的方法是“加锁”；持锁存取的最经济的方法之一是“多读单写”——即保证同时只有一个线程能“写cell”。</p>
<p>但是这给应用带来了负担——如果一个应用程序由多个线程（分布或不分布在多个CPU核上），在它们都要读取同一个cell、而又有某个线程要写该cell的时候，那么大家就都要挂起来等这个写操作完成了。整个应用程序在CPU使用（或者说效率）上就大大地打了折扣。</p>
<p>如果这只是一个桌面程序（例如记事本），大概没人会说什么。但如果是服务器程序（例如Web Server），那么整个网络、所有的会话就都处于等待状态了——而这个时候，服务器的CPU占用还可能远远地小于1%！</p>
<p>解决问题的终极方法，就是不解决这个问题——写cell带来了问题，那么我们就“不写cell”。我们由前面所有讲述的内容开始倒推，问题根本是由“命令式语言”这个编程范型本身决定的：用算法改变数据。</p>
<p>所以，我们回到了原始的问题：如果算法不改变cell(数据/状态/变量)呢？</p>
<h2 id="">六、函数式编程的核心概念：闭包</h2>
<p>当“过程（初阶的函数）”引入了“闭包”的概念后，整个“函数式语言”的体系建立了起来。所谓“闭包”，是指在函数运行的上下文中，所有的cells与函数之外无关，这些cells的状态仅与函数——这个运算逻辑相关，则这个上下文环境“整体地”被称为“闭包”。</p>
<p>如果换个说法，闭包就是不受函数之外影响的一堆cells。一般在实现它的时候，就是让函数持有一个“专属的(!)”内存块，并且这个内存块仅当函数本身失效的时候，才被释放。</p>
<p>一个“函数本身”何时失效呢？如果这个函数只有传入参数和传出值的功能，那么这个函数就在它传出值之后立即失效了。所以，对于整个运算逻辑——这个函数来说，它没有操作过任何（函数之外的）状态，既没有读，也没有写。对于这个逻辑来说，只有传入，也只有传出，所以它具有完全的运算确定性，它本身作为一个“结果值”来看的时候，也是确定的。</p>
<p>不过在实用时，对于上述的观念做出了一些挑战。例如说：当函数内部执行了一半的时候退出，怎么办呢？答案是：1、先不释放函数；2、过一会儿再进入。这个，就是所谓的延续（Continuation），以及在JavaScript 1.6以后推出的yield概念。同样的，正因为“的确存在”执行之后函数不释放的可能性，所以函数式语言通常是由语言引擎来维护闭包的生存周期的——任何新的概念、理论的提出，都必须保证这个生存周期可测、可维护。因此相较于命令式语言，自动内存管理在函数式语言中实现起来更为高效和简洁，它最早被实现在函数式语言(LISP)语言中，也是有其必然性的了。</p>
<p>这样一来，对于在函数之外的状态state来说，函数从来不去影响它们。函数式编程范型带来了新的模式：给函数数据（入口参数），函数给出结果（返回值）。即通过不断地函数运算来产生结果，而不改变cell(数据/状态/变量)。</p>
<p>函数式与命令式范型相比较，前者被人称为（P,D;I,O)，后者被人称为（I,O;P,D），其中：输入（I）、输出（O）、加工处理程序（P）和存储状态数据（D）。即函数式先明确（P，D）——确定的处理与数据（闭包），然后讨论在闭包上的I、O问题。而命令式先确定了I、O的方式——即state的存取问题，然后讨论P、D的设计。</p>
<h2 id="">七、状态的命名：变量、常量、端口等</h2>
<p>在整个这个“主要的编程范型”图中，也许最接近现实世界（通用应用开发）而又是纯函数式范型的语言，就是erlang了。从图中的标注来看，erlang具有这样的一些语言特性：</p>
<ol>
<li>消息传递</li>
<li>命名状态</li>
<li>端口</li>
<li>闭包</li>
<li>线程（erlang中的轻量级进程）</li>
</ol>
<p>这五个特性，其实都可以归结为erlang对“状态”的处理方式。其中：</p>
<ol>
<li>当跨节点传递状态时，采用“端口+消息传递”；</li>
<li>当跨线程（进程）传递状态时，采用“进程ID+消息传递”；</li>
<li>当在多个函数/执行过程中传递状态的，采用“闭包（函数入口参数）”。</li>
</ol>
<p>亦即是说，你可以把“端口、进程标识或函数入口参数”想像成“一个传送状态的通道”，或者干脆是用于读取其它外部代码的“状态的一个副本”的途径。</p>
<p><img src="/content/images/bkImages/1804_1318005620NTRN-9.png" alt="状态的命名"></p>
<p><strong>（图4）状态的命名</strong></p>
<p>对于上述特性，erlang在整个过程中允许为状态命名（全局的或局部的）——变量。但是，该变量只能一次赋值——向端口和进程ID传递消息是一次性的，而函数参数上的变量赋值/匹配也是一次性的。尽管对状态“是否已赋值”需要进行有效性检测，从而给系统带来风险，但也是使得程序可读性和应用性能变得“稍微好一些”的唯一方式。</p>
<p>在“主要的编程范型”图中，缘于erlang对“命名的状态”的取舍，它被归为了“更少的说明式特性”的范畴。但同样的原因，它也是我们目前“（相对）最易用”的工业级的纯函数式语言。</p>
<p>同样，在这个分支上还有一个后起之秀，就是“对象能力编程”。这在最近的报道中，已有基于Scala的Actor模型进行的实现。尽管Scala是在Java上的一个实现，但它拥有完整的函数式语言特性，并使用了面向对象的一些语法与思想，在加入“对象能力类型（Object Capability Types，OCT）”之后，它拥有了跨Actor传递对象（整个对象可以视为一个状态/cell）的能力——在必要的时候，目标Actor会将接收到的对象再次本地化(local cell)。</p>
<h2 id="lispschemehaskellprologfortranpascalml">八、语言的底本：LISP/Scheme/Haskell, Prolog, Fortran/Pascal, ML</h2>
<p>从语言沿革的进化关系来看，Fortran位于高级语言的基底位置，基本上来说，它是现今绝大多数过程式/命令式语言的底本，在这个分支上主要发展的有Algol、Simula、Pascal与C。后来出现的各种面向对象编程语言，主要受到Simula跟Smalltalk的影响。</p>
<p>从Fortran之后，LISP成为所有函数式语言的底本，但由于早期LISP的应用性极差，所以Scheme吸取了Algol与LISP的一些特性，成为函数式语言发展的主要力量之一。在1987年之后，从Scheme、Smalltalk等演化出来的Haskell，也成为不可小视的新生力量。</p>
<p><img src="/content/images/bkImages/1804_1318005633TQ27-9.png" alt="函数式语言的庞大家族"></p>
<p><strong>（图5）函数式语言的庞大家族</strong></p>
<p>Prolog这个语言的独特的开创性在于：它主要描述通过逻辑事实进行推论并得出结论的过程，它的运算对象并非直接含义上的“数据”，而是一种接近人的思维的抽象：逻辑子句。这种新的、对数据的抽象开启了一个语言分支。</p>
<p>在图中几乎总是与Scheme一起出现的ML(Meta Language)是一种，它的一个比较普及的、方言化的实现是SML(Standard ML)。在这个语言分支上，一个更晚出现而又颇富盛名的语言是Caml/OCaml（Caml, Categorical Abstract Machine Language）。基本上，它看起来象是在ML的函数式语言特性上加上：</p>
<ol>
<li>命名（持久性常量）</li>
<li>cell</li>
</ol>
<p>Objective Caml (OCaml)支持面向对象编程，而使它更为众所周知的是：ECMAScript Ed4（Javascript 2）的标准规范，是采用OCaml这个语言来“定义”——并同时实现的。而微软的F#也是基于OCaml在函数式语言上方向上发展的。</p>
<p>另一个函数式的分支是数据流编程，它的底本语言是Dataflow——图中出现的Pipes/MapReduce是两种不同的机制，而非确定的语言。在这个分支上，现实中主要采用数据流编程范型的语言其实是LabVIEW。相对于数据流（驱动的）编程来讲时，命令式语言也被称为控制流（驱动的）编程语言。数据流编程在函数式这个分支中也是有开创意义的，它带来了图化、网络图化编程这样一种格局。</p>
<p>在这一小节（以及图）里面，主要提及到的底本语言的出现时间为：</p>
<ul>
<li>1957 FORTRAN</li>
<li>1958 ALGOL</li>
<li>1960 LISP</li>
<li>1962 SIMULA</li>
<li>1969 Smalltalk</li>
<li>1970 Prolog</li>
<li>1971 Dataflow</li>
<li>1972 C</li>
<li>1973 ML</li>
<li>1975 Pascal</li>
<li>1975 Scheme</li>
<li>1990 Haskell</li>
<li>1996 OCaml</li>
</ul>
<p><strong>延伸阅读：</strong></p>
<blockquote>
<ul>
<li>
<p><a href="/1-121.html">像大师们一样思考——从“UML何时死掉”谈起</a></p>
</li>
<li>
<p><a href="/1-135.html">世界需要一种什么样的语言</a></p>
</li>
<li>
<p><a href="/1-137.html">表面的简洁</a></p>
</li>
<li>
<p><a href="/1-85.html">从表达式到函数：表面的简洁</a></p>
</li>
<li>
<p><a href="/1-118.html">无废话JavaScript（上）</a></p>
</li>
<li>
<p><a href="/1-119.html">无废话JavaScript（下）</a></p>
</li>
</ul>
</blockquote>
</div>
            </section>
<!-- removed by aimingoo
            <footer class="post-footer">
                {-{!> "post_author"}}
            </footer>
-->
        </article>

        <aside class="post-nav">
            <span class="post-nav-prev">
                上一篇
                <a href="/1-249.html">
                    真相总是能被还原的——兼批一切口号党、标题党与托托党！
                </a>
            </span>

            <span class="post-nav-next" >
                <a href="/1-250.html">
                    我们都只是一个偶然的存在，并因为偶然而继续存在
                </a>
                下一篇
            </span>
        </aside>
        <section class="post comments">
<div id="gitment-root"></div>

<link rel="stylesheet" type="text/css" href="/assets/css/gitment.default.css" />
<script src="/assets/js/gitmint.browser.js"></script>

<style>
a.gitment-editor-footer-tip { display: none; }
.gitment-container.gitment-footer-container { display: none; }
</style>

<script type="text/javascript">
	var SHORT_ID = function(url) { return url.replace(/[\?#].*$/, '').replace(/\/((default|index)\..{1,4})?$/,'').replace(/^.*\/|.html$/g, '') };
	var gitment = new Gitmint({
	  id: SHORT_ID(location.href),
	  owner: 'aimingoo',
	  repo: 'aimingoo.github.io',
	  lang: 'zh-CN'
	});
	gitment.render('gitment-root');
</script>
<noscript>Please enable JavaScript to view theses comments.</noscript>
</section>    </div>
    <div id="sidebar" class="sidebar col-md-4 col-lg-4">

            <div class="widget widget-profile">
        <div class="widget-profile-cover overlay " style="background-image: url(/content/images/2017/10/IMG_5294-1.jpg)"></div>
        <div class="widget-profile-header">
            <a class="widget-profile-logo" href="/author/aimingoo/">
                <img src="/content/images/2017/10/IMG_5559-1.jpg" alt="Aimingoo&#x27;s Blog" />
            </a>
        </div>
        <span class="widget-profile-title label label-xlg label-minty arrowed-in arrowed-in-right">aimingoo</span>
        <hr>
        <p class="widget-profile-desc">
                云色青青若醉，还与东湖寐
        </p>
        <hr>
        <!-- replaced by aimingoo -->
        <script type="text/javascript" src="/profile-aimingoo"></script>
    </div>


<!-- replaced by aimingoo
    {-{> "tag_cloud"}}
-->
        <script type="text/javascript" author="aimingoo" src="/tag-cloud"></script>

        <div class="widget widget-toc">
    <div class="widget-title">
        <div class="widget-title-meta">
            <i class="fa fa-list-ul"></i>&nbsp;
            <span class="title-meta-word">文章目录</span>
        </div>
    </div>
    <nav id="tocScrollspy">
        <ul id="toc" class="toc"></ul>
    </nav>
</div>
</div>
</main>


        <footer class="site-footer clearfix">
            <div class="footer-meta container">
                <section class="copyright"><a href="https://aimingoo.github.io">Aimingoo&#x27;s Blog</a> &copy; 2021</section>
                <section class="poweredby">Proudly published with <a href="https://ghost.org">Ghost</a>, Theme <a href="https://github.com/xiaoluoboding/kaldorei">Kaldorei</a></section>
            </div>
        </footer>

    </div>

    <div id="backTop" class="backTop">
        <button class="btn btn-inverse">
            <i class="fa fa-chevron-up"></i>
        </button>
    </div>

    <script type="text/javascript" src="/assets/js/jquery-1.12.0.min.js"></script>
    

    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="/assets/js/timeAgo.js"></script>
    <script type="text/javascript" src="/assets/js/index.js"></script>
    <script type="text/javascript" src="/assets/plugins/bootstrap-3.3.5/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/assets/plugins/highlight-9.1.0/highlight.pack.js"></script>
    <script type="text/javascript" src="/assets/plugins/jquery-toc-0.3.5/jquery.toc.js"></script>
    <script type="text/javascript" src="/assets/plugins/velocity-1.2.3/velocity.min.js"></script>
    <script type="text/javascript" src="/assets/plugins/velocity-1.2.3/velocity.ui.min.js"></script>
    <script type="text/javascript" src="/assets/plugins/anijs-0.9.3/anijs-min.js"></script>
    <script type="text/javascript" src="/assets/plugins/anijs-0.9.3/anijs-helper-scrollreveal-min.js"></script>
    <script type="text/javascript" src="/assets/plugins/github-repo-jquery-widget/jquery.githubRepoWidget.min.js"></script>
    <script type="text/javascript" src="/assets/plugins/fancybox-2.1.5/jquery.fancybox.pack.js"></script>
</body>

</html>

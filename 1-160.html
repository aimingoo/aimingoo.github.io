

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>前端要给力之：代码可以有多烂？</title>
    <meta name="description" content="">

    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="shortcut icon" href="favicon.ico">
    <link rel="stylesheet" type="text/css" href="assets/css/screen.css?v=0d5025f8e3">
    <!-- <link rel="stylesheet" type="text/css" href="//fonts.useso.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" /> -->
    <link rel="stylesheet" type="text/css" href="assets/plugins/font-awesome-4.5.0/css/font-awesome.min.css?v=0d5025f8e3">
    <link rel="stylesheet" type="text/css" href="assets/plugins/bootstrap-3.3.5/css/bootstrap.min.css?v=0d5025f8e3">
    <link rel="stylesheet" type="text/css" href="assets/plugins/highlight-9.1.0/styles/monokai-sublime.css?v=0d5025f8e3">
    <link rel="stylesheet" type="text/css" href="assets/plugins/anijs-0.9.3/anicollection.min.css?v=0d5025f8e3">
    <link rel="stylesheet" type="text/css" href="assets/plugins/fancybox-2.1.5/jquery.fancybox.css?v=0d5025f8e3">
    <meta name="referrer" content="no-referrer-when-downgrade">
    
    <meta property="og:site_name" content="Aimingoo's Blog">
    <meta property="og:type" content="article">
    <meta property="og:title" content="前端要给力之：代码可以有多烂？">
    <meta property="og:description" content="1、烂代码是怎么定义的？ !KissyUI是淘宝Kissy这个前端项目的一个群，龙藏同学在看完我在公司内网的&amp;ldquo;读烂代码系列&amp;rdquo;之后就在群里问呵：烂代码是怎么定义的？   是呵，到底什么才算烂代码呢？这让我想到一件事，是另一个网友在gtalk上问我的一个问题：他需要a,b,c三个条件全真时为假，全假时也为假，请问如何判断。   接下来KissyUI群里的同学给出了很多答案：   // 1. 圆心   if (a&amp;amp;&amp;amp;b&amp;amp;&amp;amp;c || !a&amp;amp;&amp;amp;!b&amp;amp;&amp;amp;!c){       return false   }   // 2. 龙藏   (a ^ b) &amp;amp; c   // 3. 愚公(我给gtalk上的提问者)的答案   (a xor">
    <meta property="og:url" content="http://aimingoo.github.io/1-160.html">
    <meta property="article:published_time" content="2010-11-26T01:53:00.000Z">
    <meta property="article:modified_time" content="2017-05-20T15:26:29.000Z">
    <meta property="article:tag" content="语言">
    <meta property="article:tag" content="框架">
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="前端要给力之：代码可以有多烂？">
    <meta name="twitter:description" content="1、烂代码是怎么定义的？ !KissyUI是淘宝Kissy这个前端项目的一个群，龙藏同学在看完我在公司内网的&amp;ldquo;读烂代码系列&amp;rdquo;之后就在群里问呵：烂代码是怎么定义的？   是呵，到底什么才算烂代码呢？这让我想到一件事，是另一个网友在gtalk上问我的一个问题：他需要a,b,c三个条件全真时为假，全假时也为假，请问如何判断。   接下来KissyUI群里的同学给出了很多答案：   // 1. 圆心   if (a&amp;amp;&amp;amp;b&amp;amp;&amp;amp;c || !a&amp;amp;&amp;amp;!b&amp;amp;&amp;amp;!c){       return false   }   // 2. 龙藏   (a ^ b) &amp;amp; c   // 3. 愚公(我给gtalk上的提问者)的答案   (a xor">
    <meta name="twitter:url" content="http://aimingoo.github.io/1-160.html">
    <meta name="twitter:label1" content="Written by">
    <meta name="twitter:data1" content="aimingoo">
    <meta name="twitter:label2" content="Filed under">
    <meta name="twitter:data2" content="语言, 框架">
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "Aimingoo&#x27;s Blog",
        "logo": "http://aimingoo.github.io/content/images/2017/05/-----2017-05-06-12-31-48.png"
    },
    "author": {
        "@type": "Person",
        "name": "aimingoo",
        "image": {
            "@type": "ImageObject",
            "url": "http://aimingoo.github.io/content/images/2017/05/-----2017-05-06-12-23-58.png",
            "width": 944,
            "height": 858
        },
        "url": "http://aimingoo.github.io/author/aimingoo/",
        "sameAs": [
            "http://blog.csdn.net/aimingoo"
        ],
        "description": "I&#x27;m here."
    },
    "headline": "前端要给力之：代码可以有多烂？",
    "url": "http://aimingoo.github.io/1-160.html",
    "datePublished": "2010-11-26T01:53:00.000Z",
    "dateModified": "2017-05-20T15:26:29.000Z",
    "keywords": "语言, 框架",
    "description": "1、烂代码是怎么定义的？ !KissyUI是淘宝Kissy这个前端项目的一个群，龙藏同学在看完我在公司内网的&amp;ldquo;读烂代码系列&amp;rdquo;之后就在群里问呵：烂代码是怎么定义的？   是呵，到底什么才算烂代码呢？这让我想到一件事，是另一个网友在gtalk上问我的一个问题：他需要a,b,c三个条件全真时为假，全假时也为假，请问如何判断。   接下来KissyUI群里的同学给出了很多答案：   // 1. 圆心   if (a&amp;amp;&amp;amp;b&amp;amp;&amp;amp;c || !a&amp;amp;&amp;amp;!b&amp;amp;&amp;amp;!c){       return false   }   // 2. 龙藏   (a ^ b) &amp;amp; c   // 3. 愚公(我给gtalk上的提问者)的答案   (a xor",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://aimingoo.github.io"
    }
}
    </script>

    <script type="text/javascript" src="shared/ghost-url.js?v=0d5025f8e3"></script>
<script type="text/javascript">
ghost.init({
	clientId: "ghost-frontend",
	clientSecret: "cb6d9de116b8"
});
</script>
    <meta name="generator" content="Ghost 0.11">
    <link rel="alternate" type="application/rss+xml" title="Aimingoo's Blog" href="rss/index.rss">
</head>

<body class="post-template tag-yu-yan tag-kuang-jia nav-closed" data-spy="scroll" data-target="#tocScrollspy">

    <div class="site-wrapper">


        


<script type="text/javascript" author="aimingoo" src="assets/js/author-switcher.js?v=0d5025f8e3"></script>

<header class="main-header">
    <nav class="container main-nav clearfix">
        <div class="main-nav-title pull-left">
            <script>
            var titleTextInBody = '<a class="blog-title" href="http://aimingoo.github.io">Aimingoo&#x27;s Blog</a>';
            var theAuthor = {slug: 'aimingoo', url: '/author/aimingoo/'};
            if (theAuthor.slug == 'joyxhy') {
                titleTextInBody = '<' + 'a class="blog-title" hr' + 'ef="' + theAuthor.url + '">麦秸的垛</a>';
            }
            document.writeln(titleTextInBody);
            </script>
        </div>
            <div class="nav pull-right">
    <ul>
            <li class="nav-" role="presentation"><a href="http://aimingoo.github.io/">首页</a></li>
            <li class="nav-" role="presentation"><a href="archives-post/">历史</a></li>
            <li class="nav-" role="presentation"><a href="about.html">关于</a></li>
    </ul>
</div>

    </nav>
</header>

<main id="container" class="container" role="main">
    <div id="content" class="content col-sm-12 col-md-8 col-lg-8">
        <article class="post tag-yu-yan tag-kuang-jia">
            <header class="post-header">
                <h1 class="post-title"><a href="1-160.html">前端要给力之：代码可以有多烂？</a></h1>
                <section class="post-meta">
                    <span class="post-meta-item">
                        <i class="fa fa-user"></i>
                        <a href="author/aimingoo/">aimingoo</a>
                    </span>
                    <span class="post-meta-item">
                        <i class="fa fa-clock-o"></i>
                        <time class="post-date" datetime="2010-11-26">6 years ago</time>
                        <time class="post-date" datetime="2010-11-26">(2010-11-26)</time>
                    </span>
                    <span class="post-meta-item post-meta-tags">
                        <i class="fa fa-tag"></i>
                        <a href="tag/yu-yan/">语言</a>, <a href="tag/kuang-jia/">框架</a>
                    </span>
                    <span class="post-meta-item pull-right">
                        
                    </span>
                </section>
            </header>

            <section class="post-content">
                <h2 id="1">1、烂代码是怎么定义的？</h2>

<p>!KissyUI是淘宝Kissy这个前端项目的一个群，龙藏同学在看完我在公司内网的“读烂代码系列”之后就在群里问呵：烂代码是怎么定义的？  </p>

<p>是呵，到底什么才算烂代码呢？这让我想到一件事，是另一个网友在gtalk上问我的一个问题：他需要a,b,c三个条件全真时为假，全假时也为假，请问如何判断。  </p>

<p>接下来KissyUI群里的同学给出了很多答案：  </p>

<pre><code class="language-javascript">// 1. 圆心  
if (a&amp;&amp;b&amp;&amp;c || !a&amp;&amp;!b&amp;&amp;!c){  
    return false  
}  
// 2. 龙藏  
(a ^ b) &amp; c  
// 3. 愚公(我给gtalk上的提问者)的答案  
(a xor b) or (a xor c)  
// 4. 提问者自己的想法  
(a + b + c) % 3  
// 5. 云谦对答案4的改进版本  
(!!a+!!b+!!c)%n  
// 6. 拔赤  
a ? (b?c:b) : (b?!b:!c)  
// 7. 吴英杰  
(a != b || b != c)  
或  
(!a != !b || !b != !c)  
// 8. 姬光  
var v = a&amp;&amp;b&amp;&amp;&amp;c;  
if(!v){  
   return false;  
}else if(v){  
   return false;  
}else{  
   return true;  
}  
</code></pre>

<p>en... 确实，我没有完全验证上面的全面答案的有效性。因为如同龙藏后来强调的：“貌似我们是要讨论什么是烂代码？”的确，我们怎么才能把代码写烂呢？上面出现了种种奇异代码，包括原来提问者的那个取巧的：  </p>

<pre><code class="language-javascript">// 4. 提问者自己的想法  
(a + b + c) % 3
</code></pre>

<pre><code> 
</code></pre>

<p>因为这个问题出现在js里面，存在弱类型的问题，即a、b、c可能是整数，或字符串等等，因此(a+b+c)%3这个路子就行不通了，所以才有了  </p>

<pre><code class="language-javascript">// 5. 云谦对答案4的改进版本  
(!!a+!!b+!!c)%n
</code></pre>

<h2 id="2">2、问题的泛化与求解：普通级别</h2>

<p>如果把上面的问题改变一下：  </p>

<ul>
<li>如果不是a、b、c三个条件，而是两个以上条件呢？  </li>
<li>如果强调a、b、c本身不一定是布尔值呢？  </li>
</ul>

<p>那么这个问题的基本抽象就是：  </p>

<pre><code class="language-javascript">// v0，对任意多个运算元求xor  
function e_xor() { ... }  

对于这个e_xor()来说，最直接的代码写法是：  
// v1，扫描所有参数，发现不同的即返回true，全部相同则返回false。  
function e_xor() {  
  var args=arguments, argn=args.length;  
  args[0] = !args[0];  
  for (var i=1; i&lt;argn; i++) {  
    if (args[0] != !args[i]) return true;  
  }  
  return false;  
}  
</code></pre>

<p>接下来，我们考虑一个问题，既然arguments就是一个数组，那么可否使用数组方式呢？事实上，据说在某些js环境中，直接存取arguments[x]的效率是较差的。因此，上面的v1版本可以有一个改版：  </p>

<pre><code class="language-javascript">// v1.1，对v1的改版  
function e_xor() {  
  var args=[].slice.call(arguments,0), argn=args.length;  
  ...  
}
</code></pre>

<p>这段小小的代码涉及到splice/slice的使用问题。因为操作的是arguments，因此splice可能导致函数入口的“奇异”变化，在不同的引擎中的表现效果并不一致，而slice则又可能导致多出一倍的数据复制。在这里仍然选用slice()的原因是：这里毕竟只是函数参数，不会是“极大量的”数组，因此无需过度考虑存储问题。  </p>

<p>   </p>

<h2 id="3">3、问题的泛化与求解：专业级别</h2>

<p>接下来，我们既然在args中得到的是一个数组，那么再用for循环就实在不那么摩登了。正确的、流行风格的、不被前端鄙视做法是：  </p>

<pre><code class="language-javascript">// v2，使用js1.6+的数组方法的实现  
function e_xor(a) {  
  return ([].slice.call(arguments,1)).some(function(b) { if (!b != !a) return true });  
}
</code></pre>

<p>为了向一些不太了解js1.6+新特性的同学解释v2这个版本，下面的代码分解了上述这个实现：  </p>

<pre><code class="language-javascript">// v2.1，对v2的详细分解  
function e_xor(a) {  
  var args = [].slice.call(arguments,1);  
  var callback = function(b) {  
    if (!b != !a) return true  
  }  
  return args.some(callback);  
}
</code></pre>

<p>some()这个方法会将数组args中的每一个元素作为参数b传给callback函数。some()有一项特性正是与我们的原始需求一致的：  </p>

<ul>
<li>当callback()返回true的时候，some()会中断args的列举然后返回true值；否则，  </li>
<li>当列举完全部元素且callback()未返回true的情况下，some()返回false值。  </li>
</ul>

<p>现在再读v2版本的e_xor()，是不是就清晰了？</p>

<p>当然，仅仅出于减少!a运算的必要，v2版本也可以有如下的一个改版：  </p>

<pre><code class="language-javascript">// v2.2，对v2的优化以减少!a运算次数  
function e_xor(a) {  
  return (a=!a, [].slice.call(arguments,1)).some(function(b) { if (!b != a) return true });  
}
</code></pre>

<p>在这行代码里，使用了连续运算：  </p>

<blockquote>
  <p><code>(a=!a, [].slice.call(arguments,1))</code></p>
</blockquote>

<p>而连续运算返回最后一个子表达式的值，即slice()后的数组。这样的写法，主要是要将代码控制在“一个表达式”。 </p>

<h2 id="4guy">4、问题的泛化与求解：Guy入门级别</h2>

<p>好了，现在我们开始v3版本的写法了。为什么呢？因为v2版本仍然不够酷，v2版本使用的是Array.some()，这个在js1.6中扩展的特既不是那么的“函数式”，还有些面向对象的痕迹。作为一个函数式语言的死忠，我认为，类似于“列举一个数组”这样的问题的最正常解法是：递归。  </p>

<p>为什么呢？因为erlang这样的纯函数式语言就不会搞出个Array.some()的思路来——当然也是有这样的方法的，只是从“更纯正”的角度上讲，我们得自己写一个。呵呵。这种“纯正的递归”在js里面又怎么搞呢？大概的原型会是这样子：  </p>

<pre><code class="language-javascript">// v3，采用纯函数式的、递归方案的框架  
function e_xor(a, b) {  ... }  
</code></pre>

<p>在这个框架里，我们设e_xor()有无数个参数，但每次我们只处理a,b两个，如果a,b相等，则我们将其中之任一，与后续的n-2个参数递归比较。为了实现“递归处理后续n-2个参数”，我们需要借用函数式语言中的一个重要概念：连续/延续(continuous)。这个东东月影曾经出专题来讲过，在这里：<a href="http://bbs.51js.com/viewthread.php?tid=85325">http://bbs.51js.com/viewthread.php?tid=85325</a>  </p>

<p>简单地说，延续就是对函数参数进行连续的回调。这个东东呢，在较新的函数式语言范式中都是支持的。为了本文中的这个例子，我单独地写个版本来分析之。我称之为tail()方法，意思是指定函数参数的尾部，它被设计为函数Function上的一个原型方法。  </p>

<pre><code class="language-javascript">Function.prototype.tail = function() {  
  return this.apply(this, [].slice.call(arguments,0).concat([].slice.call(this.arguments, this.length)));  
}
</code></pre>

<p>注意这个tail()方法的有趣之处：它用到了this.length。在javascript中的函数有两个length值，一个是foo.length，它表明foo函数在声明时的形式参数的个数；另一个是arguments.length，它表明在函数调用时，传入的实际参数的个数。也就是说，对于函数foo()来说：  </p>

<pre><code class="language-javascript">function foo(a, b) {  
  alert([arguments.length, arguments.callee.length]);  
}  
foo(x);  
foo(x,y,z);  
</code></pre>

<p>第一次调用将显示[1,2]，第二次则会显示[3,2]。无论如何，声明时的参数a,b总是两个，所以foo.length <mark> arguments.callee.length </mark> 2。  </p>

<p>回到tail()方法。它的意思是说：  </p>

<pre><code class="language-javascript">Function.prototype.tail = function() {  
  return this.apply( // 重新调用函数自身  
    this, // 以函数foo自身作为this Object  
    [].slice.call(arguments,0) // 取调用tail时的全部参数，转换为数组  
    .concat( // 数组连接  
      [].slice.call(this.arguments, // 取本次函数foo调用时的参数，由于tail()总在foo()中调用，因此实际是取最近一次foo()的实际参数  
        this.length)  // 按照foo()声明时的形式参数个数，截取foo()函数参数的尾部  
    )  
  );  
}
</code></pre>

<p>那么tail()在本例中如何使用呢？  </p>

<pre><code class="language-javascript">// v3.1，使用tail()的版本  
function e_xor(a, b) {  
  if (arguments.length == arguments.callee.length) return !a != !b;  
  return (!a == !b ? arguments.callee.tail(b) : true);  
}
</code></pre>

<p>这里又用到了arguments.callee.length来判断形式参数个数。也就是说，递归的结束条件是：只剩下a,b两个参数，无需再扫描tail()部分。当然，return中三元表达式(?:)右半部分也会中止递归，这种情况下，是已经找到了一个不相同的条件。  </p>

<p>在这个例子中，我们将e_xor()写成了一个尾递归的函数，这个尾递归是函数式的精髓了，只可惜在js里面不支持它的优化。WUWU~~ 回头我查查资源，看看新的chrome v8是不是支持了。v8同学，尚V5否？:)</p>

<h2 id="5guy">5、问题的泛化与求解：Guy进阶级别</h2>

<p>从上一个小节中，我们看到了Guy解决问题的思路。但是在这个级别上，第一步的抽象通常是最关键的。简单地说，V3里认为：  </p>

<pre><code class="language-javascript">// v3，采用纯函数式的、递归方案的框架  
function e_xor(a, b) {  ... }  
</code></pre>

<p>这个框架抽象本身可能是有问题。正确的理解不是“a,b求异或”，而是“a跟其它元素求异或”。由此，v4的框架抽象是：</p>

<pre><code class="language-javascript">// v4，更优的函数式框架抽象，对接口的思考  
function e_xor(a) {  ... }  
</code></pre>

<p>在v3中，由于每次要向后续部分传入b值，因此我们需要在tail()中做数组拼接concat()。但是，当我们使用v4的框架时，b值本身就隐含在后续部分中，因此无需拼接。这样一来，tail()就有了新的写法——事实上，这更符合tail()的原意，如果真的存在拼接过程，那它更应由foo()来处理，而不是由tail()来处理。  </p>

<pre><code class="language-javascript">// 更符合原始抽象含义的tail方法  
Function.prototype.tail = function() {  
  return this.apply(this, [].slice.call(this.arguments, this.length));  
}
</code></pre>

<p>在v4这个版本中的代码写法，会变得更为简单：  </p>

<pre><code class="language-javascript">// v4.1，相较于v3更为简单的实现  
function e_xor(a) {  
  if (arguments.length &lt; 2) return false;  
  return (!a == !arguments[1] ? arguments.callee.tail() : true);  
}  
// v4.1.1，一个不使用三元表达式的简洁版本  
function e_xor(a) {  
  if (arguments.length &lt; 2) return false;  
  if (!arguments[1] != !a) return true;  
  return arguments.callee.tail();  
}
</code></pre>

<h2 id="6guy">6、问题的泛化与求解：Guy无阶级别</h2>

<p>所谓无阶级别，就是你知道他是Guy，但不知道可以Guy到什么程度。例如，我们可以在v4.1版本的e_xor()中发现一个模式，即：</p>

<ul>
<li>真正的处理逻辑只有第二行。</li>
</ul>

<p>由于其它都是框架部分，所以我们可以考虑一种编程范式，它是对tail的扩展，目的是对在tail调用e_xor——就好象对数组调用sort()方法一样。tail的含义是取数据，而新扩展的含义是数组与逻辑都作为整体。例如：  </p>

<pre><code class="language-javascript">// 在函数原型上扩展的tailed方法，用于作参数的尾部化处理  
Function.prototype.tailed = function() {  
  return function(f) {  // 将函数this通过参数f保留在闭包上  
    return function() {  // tailed()之后的、可调用的e_xor()函数  
      if (arguments.length &lt; f.length+1) return false;  
      if (f.apply(this, arguments)) return true;  // 调用tailed()之前的函数f  
      return arguments.callee.apply(this, [].slice.call(arguments, f.length));  
    }  
  }(this)  
}
</code></pre>

<p>tailed()的用法很简单：  </p>

<pre><code class="language-javascript">e_xor = function(a){  
  if (!arguments[1] != !a) return true;  
}.tailed();
</code></pre>

<p>简单的来看，我们可以将xor函数作为tailed()的运算元，这样一样，我们可以公开一个名为tailed的公共库，它的核心就是暴露一组类似于xor的函数，开发者可以使用下面的编程范式来实现运算。例如：</p>

<pre><code class="language-javascript">/* tiny tailed library, v0.0.0.1 alpha. by aimingoo. */  
Function.prototype.tailed = ....;  
// 对参数a及其后的所有参数求异或  
function xor(a) {  
  if (!arguments[1] != !a) return true;  
}  
// ...更多类似的库函数
</code></pre>

<p>那么，这个所谓的tailed库该如何用呢？很简单，一行代码：  </p>

<pre><code class="language-javascript">// 求任意多个参数的xor值  
xor.tailed()(a,b,c,d,e,f,g);  
</code></pre>

<p>现在我们得到了一个半成熟的、名为tailed的开放库。所谓半成熟，是因为我们的tailed()还有一个小小缺陷，下面这行代码：  </p>

<pre><code class="language-javascript">if (arguments.length &amp;lt; f.length+1) return false;  
</code></pre>

<p>中间的f.length+1的这个“1”，是一个有条件的参数，它与xor处理数据的方式有关。简单的说，正是因为要比较a与arguments[1]，所这里要+1，如果某种算法要比较 多个运算元，则tailed()就不通用了。所以正确的、完善的tailed应该允许调用者指定终止条件。例如：  </p>

<pre><code class="language-javascript">// less_one()作为tailed库函数中的全局常量，以及缺省的closed条件  
// 当less_one返回true时，表明递归应该终止  
function less_one(args, f)  {  
  if (args.length &lt; f.length+1) return true;  
}  
// 在函数原型上扩展的tailed方法，用于作参数的尾部化处理  
Function.prototype.tailed = function(closed) {  
  return function(f) {  // 将函数this通过参数f保留在闭包上  
    return function() {  // tailed()之后的、可调用的e_xor()函数  
      if ((closed||less_one).apply(this, [arguments,f])) return false;  
      if (f.apply(this, arguments)) return true;  // 调用tailed()之前的函数f  
      return arguments.callee.apply(this, [].slice.call(arguments, f.length));  
    }  
  }(this)  
}
</code></pre>

<p>使用的方法仍然是：  </p>

<pre><code class="language-javascript">xor.tailed()(a,b,c,d,e,f,g);  
// 或者  
xor.tailed(less_one)(a,b,c,d,e,f,g);  
</code></pre>

<p>在不同的运算中，less_one()可以是其它的终止条件。</p>

<p>现在，在这个方案——我的意思是tailed library这个库够Guy了吗？不。所谓意淫无止尽，淫人们自有不同的淫法。比如，在上面的代码中我们可以看到一个问题，就是tailed()中有很多层次的函数闭包，这意味着调用时效率与存储空间都存在着无谓的消耗。那么，有什么办法呢？比如说？哈哈，我们可以搞搞范型编程，弄个模板出来：</p>

<pre><code class="language-javascript">/* tiny tailed library with templet framework, v0.0.0.1 beta. by aimingoo. */  
Function.prototype.templeted = function(args) {  
  var buff = ['[', ,'][0]'];  
  buff[1] = this.toString().replace(/_([^_]*)_/g, function($0,$1) { return args[$1]||'_'});  
  return eval(buff.join(''));  
}  
function tailed() {  
  var f = _execute_;  
  if (_closed_(arguments, f)) return false;  
  if (f.apply(this, arguments)) return true;  
  return arguments.callee.apply(this, [].slice.call(arguments, f.length));  
}  
function less_one(args, f)  {  
  if (args.length &lt; f.length+1) return true;  
}  
function xor(a) {  
  if (!arguments[1] != !a) return true;  
}  
e_xor = tailed.templeted({  
  closed: less_one,  
  execute: xor  
})
</code></pre>

<p>当然，我们仍然可以做得更多。例如这个templet引擎相当的粗糙，使用eval()的方法也不如new Function来得理想等等。关于这个部分，可以再参考QoBean对元语言的处理方式，因为事实上，这后面的部分已经在逼近meta language编程了。</p>

<h2 id="7guy">7、Guy?</h2>

<p>我们在做什么？我们已经离真相越来越远了。或者说，我故意地带大家兜着一个又一个看似有趣，却又渐渐远离真相的圈子。  </p>

<p>我们不是要找一段“不那么烂的代码”吗？如果是这样，那么对于a,b,c三个运算条件的判断，最好的方法大概是：  </p>

<blockquote>
  <p><code>(a!=b || a!=c)</code></p>
</blockquote>

<p>或者，如果考虑到a,b,c的类型问题：</p>

<blockquote>
  <p><code>(!a!=!b || !a!=!c)</code></p>
</blockquote>

<p>如果考虑对一组运算元进行判断的情况，那么就把它当成数组，写成:  </p>

<pre><code class="language-javascript">function e_xor(a) {  
  for (var na=!a,i=1; i&lt;arguments.length; i++) {  
    if (!arguments[i] != na) return true  
  }  
  return false;  
}
</code></pre>

<p>对于这段代码，我们使用JS默认对arguments的存取规则，有优化就优化，没有就算了，因为我们的应用环境并没有提出“这里的arguments有成千上万个”或“e_xor()调用极为频繁”这样的需求。如果没有需求，我们在这方面所做的优化，就是白费功能——除了技术上的完美之外，对应用环境毫无意义。</p>

<p>够用了。我们的所学，在应用环境中已经足够，不要让技巧在你的代码中泛滥。所谓技术，是控制代码复杂性、让代码变得优美的一种能力，而不是让技术本身变得强大或完美。</p>

<p>所以，我此前在“读烂代码”系统中讨论时，强调的其实是三个过程：</p>

<ul>
<li>先把业务的需求想清楚，  </li>
<li>设计好清晰明确的调用接口，  </li>
<li>用最简单的、最短距离的代码实现。</li>
</ul>

<p>其它神马滴，都系浮云。  </p>

<blockquote>
  <p>注：本文从第2小节，至第6小节，仅供对架构、框架、库等方面有兴趣的同学学习研究，有志于在语言设计、架构抽象等，或基础项目中使用相关技术的，欢迎探讨，切勿滥用于一般应用项目。</p>
</blockquote>
            </section>
<!-- removed by aimingoo
            <footer class="post-footer">
                {-{!> "post_author"}}
            </footer>
-->
        </article>

        <aside class="post-nav">
            <span class="post-nav-prev">
                上一篇
                <a href="1-159.html">
                    从“架构师书单”讲开去
                </a>
            </span>

            <span class="post-nav-next">
                <a href="1-161.html">
                    继承与混合，略谈系统的构建方式
                </a>
                下一篇
            </span>
        </aside>

        <section class="post comments">
<div id="gitment-root"></div>

<link rel="stylesheet" type="text/css" href="assets/css/gitment.default.css?v=0d5025f8e3">
<script src="assets/js/gitment.browser.js?v=0d5025f8e3"></script>

<script type="text/javascript">
	var SHORT_ID = function(url) { return url.replace(/\?.*$/, '').replace(/^.*\/|.html$/g, '') };
	var gitment = new Gitment({
	  id: SHORT_ID(location.href),
	  owner: 'aimingoo',
	  repo: 'aimingoo.github.io',
	  oauth: { client_id: 'c1285a991ba7db5c395a' }
	});
	gitment.render('gitment-root');
</script>
<noscript>Please enable JavaScript to view theses comments.</noscript>
</section>    </div>
    <div id="sidebar" class="sidebar col-md-4 col-lg-4">

            <div class="widget widget-profile">
        <div class="widget-profile-cover overlay no-cover"></div>
        <div class="widget-profile-header">
            <a class="widget-profile-logo" href="author/aimingoo/">
                <img src="content/images/2017/05/-----2017-05-06-12-23-58.png" alt="Aimingoo's Blog">
            </a>
        </div>
        <span class="widget-profile-title label label-xlg label-minty arrowed-in arrowed-in-right">aimingoo</span>
        <hr>
        <p class="widget-profile-desc">
                I'm here.
        </p>
        <hr>
        <!-- replaced by aimingoo -->
        <script type="text/javascript" src="profile-aimingoo"></script>
    </div>


<!-- replaced by aimingoo
    {-{> "tag_cloud"}}
-->
        <script type="text/javascript" author="aimingoo" src="tag-cloud"></script>

        <div class="widget widget-toc">
    <div class="widget-title">
        <div class="widget-title-meta">
            <i class="fa fa-list-ul"></i> 
            <span class="title-meta-word">文章目录</span>
        </div>
    </div>
    <nav id="tocScrollspy">
        <ul id="toc" class="toc"></ul>
    </nav>
</div>
</div>
</main>


        <footer class="site-footer clearfix">
            <div class="footer-meta container">
                <section class="copyright"><a href="http://aimingoo.github.io">Aimingoo's Blog</a> © 2017</section>
                <section class="poweredby">Proudly published with <a href="https://ghost.org">Ghost</a>, Theme <a href="https://github.com/xiaoluoboding/kaldorei">Kaldorei</a></section>
            </div>
        </footer>

    </div>

    <div id="backTop" class="backTop">
        <button class="btn btn-inverse">
            <i class="fa fa-chevron-up"></i>
        </button>
    </div>

    <script type="text/javascript" src="assets/js/jquery-1.12.0.min.js?v=0d5025f8e3"></script>
    

    <script type="text/javascript" src="assets/js/jquery.fitvids.js?v=0d5025f8e3"></script>
    <script type="text/javascript" src="assets/js/index.js?v=0d5025f8e3"></script>
    <script type="text/javascript" src="assets/plugins/bootstrap-3.3.5/js/bootstrap.min.js?v=0d5025f8e3"></script>
    <script type="text/javascript" src="assets/plugins/highlight-9.1.0/highlight.pack.js?v=0d5025f8e3"></script>
    <script type="text/javascript" src="assets/plugins/jquery-toc-0.3.5/jquery.toc.js?v=0d5025f8e3"></script>
    <script type="text/javascript" src="assets/plugins/velocity-1.2.3/velocity.min.js?v=0d5025f8e3"></script>
    <script type="text/javascript" src="assets/plugins/velocity-1.2.3/velocity.ui.min.js?v=0d5025f8e3"></script>
    <script type="text/javascript" src="assets/plugins/anijs-0.9.3/anijs-min.js?v=0d5025f8e3"></script>
    <script type="text/javascript" src="assets/plugins/anijs-0.9.3/anijs-helper-scrollreveal-min.js?v=0d5025f8e3"></script>
    <script type="text/javascript" src="assets/plugins/github-repo-jquery-widget/jquery.githubRepoWidget.min.js?v=0d5025f8e3"></script>
    <script type="text/javascript" src="assets/plugins/fancybox-2.1.5/jquery.fancybox.pack.js?v=0d5025f8e3"></script>
</body>


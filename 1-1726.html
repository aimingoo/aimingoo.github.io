<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>Kindle电子书中该用多大的图片</title>

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="/favicon.png">
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />
    <!-- <link rel="stylesheet" type="text/css" href="//fonts.useso.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" /> -->
    <link rel="stylesheet" type="text/css" href="/assets/plugins/font-awesome-4.5.0/css/font-awesome.min.css" />
    <link rel="stylesheet" type="text/css" href="/assets/plugins/bootstrap-3.3.5/css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="/assets/plugins/highlight-9.1.0/styles/xcode.css" />
    <link rel="stylesheet" type="text/css" href="/assets/plugins/anijs-0.9.3/anicollection.min.css" />
    <link rel="stylesheet" type="text/css" href="/assets/plugins/fancybox-2.1.5/jquery.fancybox.css" />
    <link rel="shortcut icon" href="/favicon.png" type="image/png" />
    <meta name="referrer" content="no-referrer-when-downgrade" />
    
    <meta property="og:site_name" content="Aimingoo&#x27;s Blog" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="Kindle电子书中该用多大的图片" />
    <meta property="og:description" content="注1：本文所涉及的工具，可以采用如下方法安装： # 含identify,convert,mogrify,pdfinfo,pdftoppm等 &amp;gt; brew install ghostscript imagemagick cpdf poppler # 含pdfcrop等 &amp;gt; brew cask install xquartz mactex inkscape 注2：本文缺省是使用PNG图片，使用JPG的方法是一致的（有极少数的转换工具不同）。 如果你总是将一张『足够清晰』的图片缩小到适合Kindle电子书阅读的比例，那么本文中的问题就不是问题：缩小一张普通的图片时，图片质量通常并不会变得更糟。但如果图片中使用了文字，那么麻烦来了：你不知道一张图片中该用多大的文字才能确保图片缩小之后仍然清晰；另外，你也知道的，『线条和文字』在图片缩放操作中总是会有明显的变形。 在Kindle这类电子书中使用『表格』向来是一个巨大的麻烦，其原因就在这里：表格在HTML/Markdown中通常都不友好，而当你决定直接使用图片时，缩放操作对文字和线条又不友好。 你最好的选择是：使用一个阅读器不会对它进行缩放的、" />
    <meta property="og:url" content="https://aimingoo.github.io/1-1726.html" />
    <meta property="article:published_time" content="2017-06-03T10:54:54.000Z" />
    <meta property="article:modified_time" content="2017-06-06T12:03:11.000Z" />
    <meta property="article:tag" content="电子书" />
    <meta property="article:tag" content="Kindle" />
    
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="Kindle电子书中该用多大的图片" />
    <meta name="twitter:description" content="注1：本文所涉及的工具，可以采用如下方法安装： # 含identify,convert,mogrify,pdfinfo,pdftoppm等 &amp;gt; brew install ghostscript imagemagick cpdf poppler # 含pdfcrop等 &amp;gt; brew cask install xquartz mactex inkscape 注2：本文缺省是使用PNG图片，使用JPG的方法是一致的（有极少数的转换工具不同）。 如果你总是将一张『足够清晰』的图片缩小到适合Kindle电子书阅读的比例，那么本文中的问题就不是问题：缩小一张普通的图片时，图片质量通常并不会变得更糟。但如果图片中使用了文字，那么麻烦来了：你不知道一张图片中该用多大的文字才能确保图片缩小之后仍然清晰；另外，你也知道的，『线条和文字』在图片缩放操作中总是会有明显的变形。 在Kindle这类电子书中使用『表格』向来是一个巨大的麻烦，其原因就在这里：表格在HTML/Markdown中通常都不友好，而当你决定直接使用图片时，缩放操作对文字和线条又不友好。 你最好的选择是：使用一个阅读器不会对它进行缩放的、" />
    <meta name="twitter:url" content="https://aimingoo.github.io/1-1726.html" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="aimingoo" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="电子书, Kindle" />
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "Aimingoo&#x27;s Blog",
        "logo": "https://aimingoo.github.io/content/images/2017/05/-----2017-05-06-12-31-48.png"
    },
    "author": {
        "@type": "Person",
        "name": "aimingoo",
        "image": {
            "@type": "ImageObject",
            "url": "https://aimingoo.github.io/content/images/2017/10/IMG_5559-1.jpg",
            "width": 128,
            "height": 128
        },
        "url": "https://aimingoo.github.io/author/aimingoo/",
        "sameAs": []
    },
    "headline": "Kindle电子书中该用多大的图片",
    "url": "https://aimingoo.github.io/1-1726.html",
    "datePublished": "2017-06-03T10:54:54.000Z",
    "dateModified": "2017-06-06T12:03:11.000Z",
    "keywords": "电子书, Kindle",
    "description": "注1：本文所涉及的工具，可以采用如下方法安装： # 含identify,convert,mogrify,pdfinfo,pdftoppm等 &amp;gt; brew install ghostscript imagemagick cpdf poppler # 含pdfcrop等 &amp;gt; brew cask install xquartz mactex inkscape 注2：本文缺省是使用PNG图片，使用JPG的方法是一致的（有极少数的转换工具不同）。 如果你总是将一张『足够清晰』的图片缩小到适合Kindle电子书阅读的比例，那么本文中的问题就不是问题：缩小一张普通的图片时，图片质量通常并不会变得更糟。但如果图片中使用了文字，那么麻烦来了：你不知道一张图片中该用多大的文字才能确保图片缩小之后仍然清晰；另外，你也知道的，『线条和文字』在图片缩放操作中总是会有明显的变形。 在Kindle这类电子书中使用『表格』向来是一个巨大的麻烦，其原因就在这里：表格在HTML/Markdown中通常都不友好，而当你决定直接使用图片时，缩放操作对文字和线条又不友好。 你最好的选择是：使用一个阅读器不会对它进行缩放的、",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://aimingoo.github.io/"
    }
}
    </script>

    <script type="text/javascript" src="/public/ghost-sdk.min.js"></script>
<script type="text/javascript">
ghost.init({
	clientId: "ghost-frontend",
	clientSecret: "e8bc7646b93e"
});
</script>
    <meta name="generator" content="Ghost 1.14" />
    <link rel="alternate" type="application/rss+xml" title="Aimingoo&#x27;s Blog" href="https://aimingoo.github.io/rss/" />
</head>

<body class="post-template tag-dian-zi-shu tag-kindle nav-closed" data-spy="scroll" data-target="#tocScrollspy">

    <div class="site-wrapper">

        


<header class="main-header">
    <nav class="container main-nav clearfix">
        <div class="main-nav-title pull-left">
            <script>
            var titleTextInBody = '<a class="blog-title" href="https://aimingoo.github.io">Aimingoo&#x27;s Blog</a>';
            var theAuthor = {slug: 'aimingoo', url: '/author/aimingoo/'};
            if (theAuthor.slug == 'joyxhy') {
                titleTextInBody = '<' + 'a class="blog-title" hr' + 'ef="' + theAuthor.url + '">麦秸的垛</a>';
            }
            document.writeln(titleTextInBody);
            </script>
        </div>
            <div class="nav pull-right">
    <ul>
            <li class="nav-" role="presentation"><a href="https://aimingoo.github.io/">首页</a></li>
            <li class="nav-" role="presentation"><a href="https://aimingoo.github.io/author/joyxhy/">麦秸的垛</a></li>
            <li class="nav-" role="presentation"><a href="https://aimingoo.github.io/archives-post/">历史</a></li>
            <li class="nav-" role="presentation"><a href="https://aimingoo.github.io/about/">关于</a></li>
    </ul>
</div>

    </nav>
</header>

<script type="text/javascript" author="aimingoo" src="/assets/js/author-switcher.js"></script>

<main id="container" class="container" role="main">
    <div id="content" class="content col-sm-12 col-md-8 col-lg-8">
        <article class="post tag-dian-zi-shu tag-kindle">
            <header class="post-header">
                <h1 class="post-title u-aimingoo"><a href="/1-1726.html">Kindle电子书中该用多大的图片</a></h1>
                <section class="post-meta">
                    <span class="post-meta-item">
                        <i class="fa fa-user"></i>
                        <a href="/author/aimingoo/">aimingoo</a>
                    </span>
                    <span class="post-meta-item">
                        <i class="fa fa-clock-o"></i>
                        <time class="post-date" datetime="2017-06-03T18:54:54.5454+08:00" timeago="true"></time>
                        <time class="post-date" datetime="2017-06-03">(2017-06-03)</time>
                    </span>
                    <span class="post-meta-item post-meta-tags">
                        <i class="fa fa-tag"></i>
                        <a href="/tag/dian-zi-shu/">电子书</a>, <a href="/tag/kindle/">Kindle</a>
                    </span>
                    <span class="post-meta-item pull-right">
                        
                    </span>
                </section>
            </header>

            <section class="post-content">
                <div class="kg-card-markdown"><blockquote>
<p>注1：本文所涉及的工具，可以采用如下方法安装：</p>
</blockquote>
<pre><code class="language-bash"># 含identify,convert,mogrify,pdfinfo,pdftoppm等
&gt; brew install ghostscript imagemagick cpdf poppler
# 含pdfcrop等
&gt; brew cask install xquartz mactex inkscape
</code></pre>
<blockquote>
<p>注2：本文缺省是使用PNG图片，使用JPG的方法是一致的（有极少数的转换工具不同）。</p>
</blockquote>
<p>如果你总是将一张『足够清晰』的图片缩小到适合Kindle电子书阅读的比例，那么本文中的问题就不是问题：缩小一张普通的图片时，图片质量通常并不会变得更糟。但如果图片中使用了文字，那么麻烦来了：你不知道一张图片中该用多大的文字才能确保图片缩小之后仍然清晰；另外，你也知道的，『线条和文字』在图片缩放操作中总是会有明显的变形。</p>
<p>在Kindle这类电子书中使用『表格』向来是一个巨大的麻烦，其原因就在这里：表格在HTML/Markdown中通常都不友好，而当你决定直接使用图片时，缩放操作对文字和线条又不友好。</p>
<p>你最好的选择是：使用一个阅读器不会对它进行缩放的、确定大小的图片。</p>
<p>那么这样一张图片应该是多大呢？</p>
<h2 id="">阅读器有多大，图片就有多大</h2>
<p>答案如标题所说。只要你确切知道阅读器（的可阅读区）的大小，那么制作相同大小的图片就好了。不过对于Kindle——当然也可能包括别的电子书阅读器来说，这个大小要打个折扣。这是因为Kindle设定图片最大宽高度不得超过大约80%的可阅读区。一旦超过这个大小——该值其实是一个不确定的魔法数值，这在后面会更讲到——那么阅读器就会主动缩小这个图片。</p>
<p>Kindle发行过的一些阅读器的规格主要包括（相关数据<a href="http://socialcompare.com/en/comparison/amazon-kindle-product-line-comparison">在这里</a>，最新近的一些<a href="http://www.toptenreviews.com/mobile/ebook-readers/best-kindle-comparisons/">在这里</a>）：</p>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;border-color:#ccc;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#ccc;color:#333;background-color:#fff;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#ccc;color:#333;background-color:#f0f0f0;}
.tg .tg-yw4l{vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-yw4l">分辨率</th>
    <th class="tg-yw4l">类型</th>
    <th class="tg-yw4l">Pixel Per Inch</th>
  </tr>
  <tr>
    <td class="tg-yw4l">1024x600</td>
    <td class="tg-yw4l">ISP LCD</td>
    <td class="tg-yw4l">169/171 PPI</td>
  </tr>
  <tr>
    <td class="tg-yw4l">1280x800</td>
    <td class="tg-yw4l">ISP LCD</td>
    <td class="tg-yw4l">149/189/216/252 PPI</td>
  </tr>
  <tr>
    <td class="tg-yw4l">1920x1200</td>
    <td class="tg-yw4l">ISP LCD</td>
    <td class="tg-yw4l">254/323 PPI</td>
  </tr>
  <tr>
    <td class="tg-yw4l">2560x1600</td>
    <td class="tg-yw4l">ISP LCD</td>
    <td class="tg-yw4l">339 PPI</td>
  </tr>
  <tr>
    <td class="tg-yw4l">800x600</td>
    <td class="tg-yw4l">E Ink</td>
    <td class="tg-yw4l">167 PPI</td>
  </tr>
  <tr>
    <td class="tg-yw4l">1024x758</td>
    <td class="tg-yw4l">E Ink</td>
    <td class="tg-yw4l">212 PPI</td>
  </tr>
  <tr>
    <td class="tg-yw4l">1200x824</td>
    <td class="tg-yw4l">E Ink</td>
    <td class="tg-yw4l">150 PPI</td>
  </tr>
  <tr>
    <td class="tg-yw4l">1448x1072</td>
    <td class="tg-yw4l">E Ink</td>
    <td class="tg-yw4l">300 PPI</td>
  </tr>
</table>
<p>不仅如此，Kindle还发行过一系列平板的版本（当然使用的是LCD屏而不是电子墨水屏），这些屏幕的规格就更复杂了，例如官方公布的一些规格（<a href="https://developer.amazon.com/public/solutions/devices/fire-tablets/specifications/01-device-and-feature-specifications">在这里</a>）。</p>
<p>综合上面的数据，从实用性的角度来说，我们应该制作宽度小于600*80%左右大小的图片。这条规则在大多数设备上都是适用的——关于这个问题其实是有过广泛的讨论的（例如<a href="https://www.epubble.com/kindle-maximum-image-size/">在这里</a>，以及amazon开发者信息<a href="https://developer.amazon.com/public/solutions/devices/fire-tablets/app-development/01--screen-layout-and-resolution">在这里</a>）。但这个值不但与设备有关，甚至还与不同的Kindle版本有关，以至于有人发布出测试用的电子书，用来确定在不同设备上的适配图片大小（<a href="https://www.epubble.com/wp-content/download/KindleMaximumImageSize.prc">Kindle Maximum Image Size (PRC)</a> ）。</p>
<p>好吧，总之我们是只看结论的对不。那么，这个结论如下：</p>
<blockquote>
<p>建议你将图片的大小控制在<code>520*622px</code>以内。</p>
</blockquote>
<p>也就是说，图片宽度在520px以内（<code>640*0.8125</code> or <code>600*.87</code>）。</p>
<h2 id="">如何做这样大小的图片</h2>
<p>下面我们来讲『如何做』。</p>
<h3 id="">什么是『这样大小』</h3>
<p>首先确定一下『这样大小』到底是怎样大。</p>
<p>因为我们所谓520px的图片，其实要从像素点换算成印刷用的厘米(cm)、英寸(in)或磅值(pt)，这些看起来麻烦的东西，通常是平面设计师的基本功。</p>
<p>在显示器上的所谓520px，实际含义是『在一个72ppi的设备上显示520pixel』（注3）。这里的PPI是『像素/英寸(Pixel Per Inch)』，这通常用在显示输出类的设备上；更经常的，你可能看到的是用Dots来表示Pixel，就是DPI了（注4）。一般情况下，这两种说法并不需要区分，都称作分辨率(Resolution ratio)、质量/精度/密度(quality/density)——具体到不同场合则是打印分辨率、显示分辨率、图片精度等等，<a href="http://www.uigreat.com/article/131">参见这里</a>）。</p>
<blockquote>
<p>注3: 对于PPI，Windows系统默认为96， Mac OS系统默认PPI 为72。在使用Macbook Pro的Retina屏时，它的默认值是110。</p>
<p>注4: 注意，我们说宽520px时实际上是在讲一张图片的&quot;Pixel Dimensions（点阵面积）&quot;中x方向的大小，而72dpi/ppi却是指获得（例如扫描设备）或输出（例如显示设备）这个点阵图时的精度。</p>
</blockquote>
<p>我们前面列出Kindel的设备参数时，设备的PPI是很复杂的，从149到339有非常多种；而它们显示具体图像的分辨率，也有800x600 .. 2560x1600等非常多种模式。不考虑其具体映射和实现的细节的话，你可以认为：</p>
<blockquote>
<p>我们使用300DPI的图片，在多数设备上总是可行的。</p>
</blockquote>
<p>那么：一张<code>520x320px</code>大小的<code>300dpi</code>的图片，到底是怎样大小呢？</p>
<blockquote>
<p>高度320px是上面所说到的622px的一半略多。这是因为我们在电子书上通常不会把一张图做到全屏大小，而使用以半屏高为上限的图片有利于书籍的自动排版。</p>
</blockquote>
<h3 id="">面积计算</h3>
<p>想知道这个大小，那么只需要在图形制作软件中新建一张图片，设置像素大小（即是Pixel Dimensions）为520x320px，然后设置分辨率为300DPI，就一切OK了——通常这种情况下我们不需要去手工计算。然而如果你在PowerPoint或Keynote里去做类似的事情，就会发现：.ppt中设置页面是使用厘米(cm)，而.key中却是使用磅（pt）。我们的难题之一，便是要做这个转换（以宽520px为例）：</p>
<ul>
<li>520/300*2.54 = 4.4026（厘米）
<ul>
<li>1英寸 = 2.54厘米</li>
</ul>
</li>
</ul>
<p>或者为了避免你总是手工计算，那么查看上面创建的图片的信息也可以（设图片名为test.png）：</p>
<blockquote>
<p>注意：identify是ImageMagick中的一个工具，在使用<code>brew install imagemagick</code>安装后会同时得到这个命令行工具。</p>
</blockquote>
<pre><code class="language-bash">&gt; identify -verbose ./test.png | grep -E 'Units:|Resolution|Print'
  Resolution: 118.11x118.11
  Print size: 4.40268 x 2.70934
  Units: PixelsPerCentimeter
</code></pre>
<p>注意identify对图片来说缺省单位是厘米（Centimeter），而不是习惯上PPI/DPI中所说的英寸（Inch），所以Resolution显示是118.11（DPCM，Dots Per Centimeter）。如果你想要显示为DPI，那么应该这样：</p>
<pre><code class="language-bash">&gt; identify -units PixelsPerInch -verbose ./test.png | grep -E 'Units:|Resolution|Print'
  Resolution: 300x300
  Print size: 1.73333 x 1.06667
  Units: PixelsPerInch
</code></pre>
<h2 id="pptkeynote">在ppt或keynote上实作</h2>
<p>我们具体使用ppt/key的时候，其实会比上面的520x320px要略大一点，然后使用参考线来辅助作图。这是为了在ppt/key中具体画图时边界上留一点余量，便于操作。具体来说，我推荐的是使用：</p>
<ul>
<li>在.ppt中设置页面大小为<code>4.8x3.5</code>cm，或</li>
<li>在.key中设置页面大小为<code>136x99</code>pt</li>
</ul>
<p>接下来在PPT中设置两三条辅助线（以PPT为例，你可以下载这个模板<a href="/content/images/attachments/standard_image_templet_520.ppt">PPT格式</a>或<a href="/content/images/attachments/standard_image_templet_520.key">Keynote格式</a>）：</p>
<ul>
<li>右、左侧2.14cm各一条</li>
<li>右侧2.26cm一条</li>
</ul>
<p>如下图所示：</p>
<p><img src="/content/images/2017/06/standard_image_templet_520.png" alt="standard_image_templet_520"></p>
<p>我们通常作图时让内容保持在正中间的<code>2.14*2</code>的范围内即可，当右侧使用到极限时会是<code>2.14+2.26cm</code>，亦即是全宽520px。同时，如果是4磅大小的文字，单行可以容纳30~31个（如图）。我建议采用4磅文字，其下限是3.5磅。</p>
<p>最后，当你在上面的页面上完成图、表之后，如果你使用PPT，那么可以直接在图形上鼠标右键，选『另存为图片』，然后选PDF（注4）；如果你使用Keynote，请在文件菜单中选『导出』，仍然也是选PDF。</p>
<blockquote>
<p>强烈说明：注意这里要用PDF！</p>
</blockquote>
<p>接下来，你在Macbook中的『预览（Preview）』工具中打开上述PDF文件，再选导出到PNG，并设置分辨率为300 dpi。即可。</p>
<p>我们验证一下这样得到的一个.png的信息（注5）：</p>
<pre><code class="language-bash">&gt; identify -verbose ./ppt533.png | grep -E 'Units:|Resolution|Print|Geometry'
  Geometry: 533x191+0+0
  Resolution: 118.11x118.11  ## 如果使用-units PixelsPerInch，则这里为300DPI
  Print size: 4.51274x1.61714
  Units: PixelsPerCentimeter
</code></pre>
<blockquote>
<p>注4: 我们后面将使用在PPT中选中图形导出的这个PDF（命名为ppt533.pdf），以及转换后的图片（ppt533.png）。稍后我们会讲述Keynote中的处理方法。此外，如果你在PPT绘制了很多东西，那么建议你先建个组(Group)再导出它们。</p>
<p>注5: 你会注意到这个宽度不是预期的520px。这是因为PPT选中图形导出时会默认添加边框，所以如果你只使用模板中间的安全部分，那么上述方法总是安全的；否则你需要使用crop工具去切掉周边的空白区。关于这个部分的内容，我们在下面还会讲到。</p>
</blockquote>
<h3 id="pdfpng">理解PDF与PNG文件大小之间的关系</h3>
<p>为了讨论这个问题，我们再检查一下上面生成的PDF文件：</p>
<pre><code class="language-bash">&gt; identify -verbose ./ppt533.pdf | grep -E 'Units:|Resolution|Print|Geometry'
  Geometry: 128x46+0+0
  Resolution: 72x72
  Print size: 1.77778x0.638889
  Units: Undefined
</code></pre>
<p>你会注意到PDF文件中<code>Units</code>值是没有的。这是PDF格式特殊的地方，事实上在它的文件格式中并没有包含Resolution、Print size和Units的信息——上面由identify得到的信息是计算出来的，而不是文件中的元数据信息。更具体地说，PDF是约定了默认使用72x72DPI的分辨率（所以Identify也直接在默认时使用了Inch作为单位，与图片的默认值不同），而且它是使用Points（磅值/点）来表明大小。那么显而易见的，上述的Print Size是简单地通过<code>128/72</code>就可以得来了——PDF默认采用72x72的DPI原因，也正在于磅值与英寸的换算关系就是<code>72:1</code>（关于这一点，请参见<a href="http://www.cnblogs.com/stronghorse/p/4913346.html">老马的文章</a>）。</p>
<p>所以现在你可以得到两个与大小相关的信息，一个是宽高信息(Pts)，也称为页面大小(Page Size)，另一个是可推算出来的打印面积(inch)。而在从PDF转换到PNG图片的过程中，通常就以这个转换后的打印面积来作为图片物理大小。</p>
<p>接下来我们来逆推一下一张300DPI的PNG图片该是怎样的。如果这张图片是如上的1.77778宽度，并且由于DPI设定是300，那么显然图片在x方向的点阵大小（pixels）应该就是<code>300*1.77778=533px</code>。具体来看上面这张通过『预览』工具导出的<code>ppt533.png</code>，它的信息就是这样：</p>
<pre><code class="language-bash">&gt; identify -units PixelsPerInch -verbose ./ppt533.png | grep -E 'Units:|Resolution|Print|Geometry'
  Geometry: 533x191+0+0
  Resolution: 300x300
  Print size: 1.77667x0.636667
  Units: PixelsPerInch
</code></pre>
<p>也就是说：在转换过程中，通常是保证<code>Print size</code>大小不变。</p>
<h3 id="ghostscriptdpi">在GhostScript中对DPI的一点不同理解</h3>
<p>如果你不想直接使用『预览』工具来导出，那么你可以为它建立一个automator任务或服务——这样就可以在命令行上使用了。或者，你也可以尝试使用GhostScript（也就是gs）这个命令行工具。</p>
<p>但是如果你使用GhostScript来将PDF转换成PNG，那么缺省情况下它是将Points直接对应地转换为Pixels的——也就是将PDF中的一个打印点，转换为图片中的一个像素点。因此假使你不使用设置分辨率的<code>-r</code>参数，那么你就将直接转换得到一个<code>128x46 pixels, 72DPI</code>的图片。</p>
<pre><code class="language-bash"># (下面这个结果显然不是你想要的)
&gt; gs -dSAFER -dBATCH -dNOPAUSE -sDEVICE=png16m -sOutputFile=128px.png ppt533.pdf
</code></pre>
<p>更进一步，如果使用<code>-r 300</code>来指定300DPI输出，那么图片要有533 px的宽度（这个我们上面已经计算过了），而原始的PDF只有128 pts的宽度。所以这时，你将会得到一个低质量的、从128放大到533的图片。</p>
<p>如果你需要用gs来转换pdf到png，那么你应该先放大这个pdf到合适的宽高大小，然后再输出。下面是其中一种可能的方案：</p>
<pre><code class="language-bash"># 先放大300/72=4.1667倍
#	- 也可以使用另一个开源工具pdfScale
#	- 目的是使pts与我们要得到的图片pixels点数对应，以确保图片质量足够
&gt; cpdf -scale-page &quot;4.1667 4.1667&quot; -scale-to-fit-scale 4.1667 -o 300dpi.pdf ppt533.pdf
# 再转换得到300DPI的图片
&gt; gs -dSAFER -dBATCH -dNOPAUSE -sDEVICE=png16m -r300 -sOutputFile=300dpi.png 300dpi.pdf
# 再reszie图片
#	- 转换成png时Page Size大小将保持不变，因此需要按72/300为比例换回去
&gt; convert 300dpi.png -resize 24% ppt533.png
</code></pre>
<p>现在我们再来看看这张图片：</p>
<pre><code class="language-bash">&gt; identify -units PixelsPerInch -verbose ppt533.png | grep -E 'Units:|Resolution|Print|Geometry'
  Geometry: 533x192+0+0
  Resolution: 300x300
  Print size: 1.77667x0.64
  Units: PixelsPerInch
</code></pre>
<p>虽然这个过程是能得到符合我们要求的图片，但的确过于复杂。我们后面将介绍一些其它不使用GhostScript的方法。</p>
<h2 id="pdf">使用导出PDF文件的方法来得到图片的一些问题</h2>
<h3 id="1pdf">1) 成批导出与转换PDF文件</h3>
<p>如果总是在PowerPoint中将图形对象选中然后右键导出成PDF，那么在成批处理时就会比较繁琐；另外，在Keynote中根本就没有这个操作。所以事实上我们一般还是会将整个的PPT/Keynote文件另存、导出为.PDF文件。这样的文件称为多页PDF——很显然地，因为我们见到的大多数PDF文件都是多页的，并且它们的页面大小是一致的。</p>
<p>然而事实上我们要处理的每张PNG图片都可能大小不同，因为在PPT/Keynote中实际作图的有效区并不一样大。你可以选择将PDF从多页转换成一批单页，或者寻找能直接处理多页PDF的工具。——不幸的是，一些情况下后面这类工具并不太容易得到。</p>
<p>所以如果你真的需要先转换成单页PDF，那么我建议你使用pdfseparate这个工具，它包含在poppler这个工具包中。用法如下：</p>
<pre><code class="language-bash"># 第二个参数是文件名模板，必须包含'%d'来作页码的占位符
#	- 目标文件的目录必须先创建(例如本例中的extract)
&gt; mkdir ./extract
&gt; pdfseparate your.pdf './extract/page%d.pdf'
</code></pre>
<h3 id="2">2) 要切掉空白</h3>
<p>在转换到图片之前，我们还得先留意一下这个.pdf外围的空白区。</p>
<p>在上例中，如果你在Keynote中导出.pdf，或者在PowerPoint中导出页面（而不是选中图形导出），那么你将导出的是整个页。我们上面说过，为了制作方便，我们的整个页其实要略大一些，而只有参考线中间部分的图形是在电子书中有效的。</p>
<p>那么我们其实需要的是自动切掉图形外围的空白区(trim/crop)——在不同的软件中，可能是这两种功能之一。你可以选择处理最终生成的.png图片，这可以仍然使用上述ImageMagick套件中的convert（你安装之后在命令行中就有了），也可以早先做一步，对.pdf进行trim/crop操作。</p>
<p>这可以使用一个非常著名（而且名实相符）的软件，叫pdfcrop。它是perl脚本，可以你可以直接从官方下载（<a href="https://sourceforge.net/projects/pdfcrop/files/">例如这里</a>），或者安装一个TeX套件包内含（使用<code>brew cask install mactex</code>）。使用起来也很简单：</p>
<pre><code class="language-bash"># Usage: pdfcrop &lt;input[.pdf]&gt; [output file]
&gt; pdfcrop xxx-300dpi.pdf croped.pdf
</code></pre>
<p>如果省略output参数，则它以input文件名自动生成<code>-crop.pdf</code>后缀的文件。</p>
<p>另一个相对来说也很可靠的工具叫pdfCropMargins，它可选的参数也更多。比如：</p>
<pre><code class="language-bash"># pdfCropMargins可选使用Ghostscript或pdftoppm作为将pdf渲染为图片的工具
#  - 参数-gsr表明使用Ghostscript（缺省是pdftoppm）, 参数-gsp表明gs可执行文件的路径
#  - 参数-p/-p4来指定relative original margin模式的边距
#   * 可以用-a/-a4指定边距的absolute offset值
#   * 参数-ap/-ap4是在剪切前计算最终页面大小时使用的(p是指preCrop)
#   * 参数-m/-mp是用在uniform模式下指定边距，并隐式地打开该模式(或显式使用-u参数)
&gt; pdf-crop-margins -p 0 -gsr -gsp /usr/local/bin/gs -o croped.pdf your.pdf
</code></pre>
<p>pdfCropMargins与pdfcrop都有resolution参数：</p>
<ul>
<li>在pdfcrop中是<code>--resolution</code></li>
<li>在pdfCropMargins中则是<code>-x/-y</code>，或<code>--xRes/--yRes</code></li>
</ul>
<p>这个参数是用在将PDF渲染成图片时提高图片精度的。因为这两个工具实际上都是先将PDF渲染成图片，然后根据图片来查找margins的，所以提高这一精度就意味着查找margins更准确。但这个参数并不会影响转换后的PDF的质量。</p>
<p>其它：</p>
<ul>
<li>在pdfcrop中建议打开<code>--hires</code>以提高crop的质量，这种情况下margin计算更精确
<ul>
<li>在pdfCropMargins中的参数<code>-ap/-ap4</code>正好相反，较不精确但速度更快</li>
</ul>
</li>
<li>使用较低的resolution值速度更快，这与内部将pdf转为图片时的速度效率有关
<ul>
<li>pdfcrop缺省的resolution值为72dpi，而pdfCropMargins缺省为150dpi</li>
</ul>
</li>
<li>在pdfCropMargins中缺省使用的pdftoppm会比gs引擎要慢一点</li>
<li>在pdfcrop中指定TeX引擎为<code>--xetex</code>时，crop运算的效果常常会出错</li>
</ul>
<h3 id="3pdfpng">3) PDF转换到PNG图片时的工具选择</h3>
<p>无论PDF是否经过crop，你最终都只是想得到图片，所以这最后一步尤其重要。</p>
<p>切记要给转换软件指定300dpi的输出精度——如上所述，我们是按这个精度来设计的图片大小。除了『预览』这个软件之外，能指定转换精度的软件看起来不少，但大多数并不合用（注意gs是可用的，但并不方便，这在之前我们已经专门讲过了）。例如下面这几个：</p>
<pre><code class="language-bash"># 使用inkscape
#   - 只能处理单页pdf，可能会因字体不匹配而出现字体异常；效果好于gs，且能将dpi置为300
&gt; inkscape --without-gui --export-dpi=300 --export-png='300dpi.png' croped-p1.pdf

# 使用ImageMagick中的convert
#   - convert的density用于指定源pdf为300dpi, 而输出的png其实总是72dpi
#   - 只能处理单页pdf，但视觉效果好于gs(也好于gs的DEVICE=pnggray)
&gt; convert -density 300 croped-p1.pdf -background white -flatten 'error-dpi.png'

# 使用pdf2png
#	- Github: https://github.com/kaorukobo/pdf2png-mac
#	- 能逐页处理，但输出png的精度受xcode中的组件影响(缺省是144dpi)
#	- 参数--dpi是用于指定源pdf的dpi值的
&gt; pdf2png --dpi 300 --page 1 --output '144dpi.png' croped.pdf
</code></pre>
<p>事实上所有这类软件都是将源PDF理解为72dpi，所以针对源来指定的Resolution值其实是用于建立一个缩放工厂（scaleFactor），以便得到等同于指定DPI大小的图像。而不同的软件的区别仅在于是否能在输出PNG时，有效的指定png图片的dpi——例如pdf2png是基于xcode的NSMakeRect()，而该组件默认精度在retina screens上就是144dpi。</p>
<p>所以请仔细review这个过程，其实完全等同于『在GhostScript中对DPI的一点不同理解』小节中所讲述的：1. 先放大PDF；2. 渲染成PNG到指定精度；3. 缩小PNG到指定大小。</p>
<h3 id="4">4) 一步到位</h3>
<p>如果你希望一步到位地解决上述问题，那么我目前只有一个工具推荐：</p>
<blockquote>
<p>注：nconvert是<strong>xnview</strong>提供的一个非商用免费工具，<a href="http://www.xnview.com/en/nconvert/">下载在这里</a></p>
</blockquote>
<pre><code class="language-bash"># 用ncovert将croped.pdf转换到png
&gt; nconvert -xall -dpi 300 -out png -o pic croped.pdf 1&gt;/dev/null
Conversion of croped.pdf into pic-0.png OK
Conversion of croped.pdf into pic-1.png OK
Conversion of croped.pdf into pic-2.png OK
...

# 或者不对original.pdf做crop操作，而是直接在nconvert中转换并autocrop图像
#	- autocrop参数格式为&quot;tol r g b&quot;，其中tol是容错值，rgb为crop掉的颜色
&gt; nconvert -xall -dpi 300 -out png -o pic -autocrop 0 255 255 255 original.pdf 1&gt;/dev/null
Conversion of croped.pdf into pic-0.png OK
...
</code></pre>
<p>所以，本文中的模板所导出的PDF(<a href="/content/images/attachments/standard_image_templet_520.pdf">在这里</a>)转换成png所采用的方法就是如下：</p>
<pre><code class="language-bash"># 在PowerPoint/Keynote中将ppt导出成.pdf，然后
#	- nconvert是从0页开始对pdf计数的
&gt; nconvert -page 0 -dpi 300 -out png -autocrop 0 255 255 255 standard_image_templet_520.pdf 1&gt;/dev/null
Conversion of standard_image_templet_520.pdf into standard_image_templet_520.png OK

# 查看png文件的信息(现在就真的是520px宽+300DPI了)
&gt; identify -units PixelsPerInch -verbose standard_image_templet_520.png | grep -E 'Units:|Resolution|Print|Geometry'
  Geometry: 520x306+0+0
  Resolution: 300x300
  Print size: 1.73333x1.02
  Units: PixelsPerInch
</code></pre>
<p>最后需要补充一点：就效果来说，基于图像autocrop与pdfcrop并没有太大的差别——反正我是分不出来。另外，你也可能想尝试使用imagemagick中的trim操作来替代autocrop：</p>
<pre><code class="language-bash"># 使用nconvert但不autocrop
&gt; nconvert -xall -dpi 300 -out png -o pic original.pdf 1&gt;/dev/null
Conversion of croped.pdf into pic-0.png OK
...

# 使用imagemagick中的mogrify工具, -fuzz 0%与autocrop中的tol参数类似
&gt; find . -name 'pic-*.png' | xargs -n1 mogrify -fuzz 0% -trim +repage
</code></pre>
</div>
            </section>
<!-- removed by aimingoo
            <footer class="post-footer">
                {-{!> "post_author"}}
            </footer>
-->
        </article>

        <aside class="post-nav">
            <span class="post-nav-prev">
                上一篇
                <a href="/1-1725.html">
                    手记6：改造Gitment
                </a>
            </span>

            <span class="post-nav-next" >
                <a href="/1-1727.html">
                    详解ImageMagick中SVG的支持
                </a>
                下一篇
            </span>
        </aside>
        <section class="post comments">
<div id="gitment-root"></div>

<link rel="stylesheet" type="text/css" href="/assets/css/gitment.default.css" />
<script src="/assets/js/gitmint.browser.js"></script>

<style>
a.gitment-editor-footer-tip { display: none; }
.gitment-container.gitment-footer-container { display: none; }
</style>

<script type="text/javascript">
	var SHORT_ID = function(url) { return url.replace(/[\?#].*$/, '').replace(/\/((default|index)\..{1,4})?$/,'').replace(/^.*\/|.html$/g, '') };
	var gitment = new Gitmint({
	  id: SHORT_ID(location.href),
	  owner: 'aimingoo',
	  repo: 'aimingoo.github.io',
	  lang: 'zh-CN'
	});
	gitment.render('gitment-root');
</script>
<noscript>Please enable JavaScript to view theses comments.</noscript>
</section>    </div>
    <div id="sidebar" class="sidebar col-md-4 col-lg-4">

            <div class="widget widget-profile">
        <div class="widget-profile-cover overlay " style="background-image: url(/content/images/2017/10/IMG_5294-1.jpg)"></div>
        <div class="widget-profile-header">
            <a class="widget-profile-logo" href="/author/aimingoo/">
                <img src="/content/images/2017/10/IMG_5559-1.jpg" alt="Aimingoo&#x27;s Blog" />
            </a>
        </div>
        <span class="widget-profile-title label label-xlg label-minty arrowed-in arrowed-in-right">aimingoo</span>
        <hr>
        <p class="widget-profile-desc">
                云色青青若醉，还与东湖寐
        </p>
        <hr>
        <!-- replaced by aimingoo -->
        <script type="text/javascript" src="/profile-aimingoo"></script>
    </div>


<!-- replaced by aimingoo
    {-{> "tag_cloud"}}
-->
        <script type="text/javascript" author="aimingoo" src="/tag-cloud"></script>

        <div class="widget widget-toc">
    <div class="widget-title">
        <div class="widget-title-meta">
            <i class="fa fa-list-ul"></i>&nbsp;
            <span class="title-meta-word">文章目录</span>
        </div>
    </div>
    <nav id="tocScrollspy">
        <ul id="toc" class="toc"></ul>
    </nav>
</div>
</div>
</main>


        <footer class="site-footer clearfix">
            <div class="footer-meta container">
                <section class="copyright"><a href="https://aimingoo.github.io">Aimingoo&#x27;s Blog</a> &copy; 2021</section>
                <section class="poweredby">Proudly published with <a href="https://ghost.org">Ghost</a>, Theme <a href="https://github.com/xiaoluoboding/kaldorei">Kaldorei</a></section>
            </div>
        </footer>

    </div>

    <div id="backTop" class="backTop">
        <button class="btn btn-inverse">
            <i class="fa fa-chevron-up"></i>
        </button>
    </div>

    <script type="text/javascript" src="/assets/js/jquery-1.12.0.min.js"></script>
    

    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="/assets/js/timeAgo.js"></script>
    <script type="text/javascript" src="/assets/js/index.js"></script>
    <script type="text/javascript" src="/assets/plugins/bootstrap-3.3.5/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/assets/plugins/highlight-9.1.0/highlight.pack.js"></script>
    <script type="text/javascript" src="/assets/plugins/jquery-toc-0.3.5/jquery.toc.js"></script>
    <script type="text/javascript" src="/assets/plugins/velocity-1.2.3/velocity.min.js"></script>
    <script type="text/javascript" src="/assets/plugins/velocity-1.2.3/velocity.ui.min.js"></script>
    <script type="text/javascript" src="/assets/plugins/anijs-0.9.3/anijs-min.js"></script>
    <script type="text/javascript" src="/assets/plugins/anijs-0.9.3/anijs-helper-scrollreveal-min.js"></script>
    <script type="text/javascript" src="/assets/plugins/github-repo-jquery-widget/jquery.githubRepoWidget.min.js"></script>
    <script type="text/javascript" src="/assets/plugins/fancybox-2.1.5/jquery.fancybox.pack.js"></script>
</body>

</html>

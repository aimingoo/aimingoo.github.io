

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>确定的世界 - The Promise's World</title>
    <meta name="description" content="">

    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="shortcut icon" href="favicon.ico">
    <link rel="stylesheet" type="text/css" href="assets/css/screen.css?v=d1e3b9c792">
    <!-- <link rel="stylesheet" type="text/css" href="//fonts.useso.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" /> -->
    <link rel="stylesheet" type="text/css" href="assets/plugins/font-awesome-4.5.0/css/font-awesome.min.css?v=d1e3b9c792">
    <link rel="stylesheet" type="text/css" href="assets/plugins/bootstrap-3.3.5/css/bootstrap.min.css?v=d1e3b9c792">
    <link rel="stylesheet" type="text/css" href="assets/plugins/highlight-9.1.0/styles/monokai-sublime.css?v=d1e3b9c792">
    <link rel="stylesheet" type="text/css" href="assets/plugins/anijs-0.9.3/anicollection.min.css?v=d1e3b9c792">
    <link rel="stylesheet" type="text/css" href="assets/plugins/fancybox-2.1.5/jquery.fancybox.css?v=d1e3b9c792">
    <meta name="referrer" content="no-referrer-when-downgrade">
    
    <meta property="og:site_name" content="Aimingoo's Blog">
    <meta property="og:type" content="article">
    <meta property="og:title" content="确定的世界 - The Promise's World">
    <meta property="og:description" content="确定的世界 - The Promise’s World —— Promise的逻辑以及在Lua中的实现     本文基于如下项目(ES6 Promise in lua v1.0.1)：             https://github.com/aimingoo/Promise      有这样一个世界 有这样的一个世界在持续地向前推进着，这个世界充满着无穷多个选择，也就是说有无穷多的可能；但对每一个选择来说，存在决定/未决两种状态，如果已经决定，则只能有yes/no两种结果之一。这个世界看起来就是下面这个样子：            那么，这个世界是确定的么？   首先，这个世界是有状态的，那些看起来存在y/n两个分支的节点，就存在于这种状态——选择还没有发生，就还有可能。   然而无论某一个节点的选择是什么，这个的世界的结果（的规模）是确定的，它必然演进到世界最下层中的状态的某一个。只不过这个最下层的规模足够大，所以在世界中的“未决”因素足够多的情况下，这个世界就看起来“">
    <meta property="og:url" content="http://aimingoo.github.io/1-196.html">
    <meta property="article:published_time" content="2015-08-10T09:35:00.000Z">
    <meta property="article:modified_time" content="2017-05-19T18:28:14.000Z">
    <meta property="article:tag" content="Javascript">
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="确定的世界 - The Promise's World">
    <meta name="twitter:description" content="确定的世界 - The Promise’s World —— Promise的逻辑以及在Lua中的实现     本文基于如下项目(ES6 Promise in lua v1.0.1)：             https://github.com/aimingoo/Promise      有这样一个世界 有这样的一个世界在持续地向前推进着，这个世界充满着无穷多个选择，也就是说有无穷多的可能；但对每一个选择来说，存在决定/未决两种状态，如果已经决定，则只能有yes/no两种结果之一。这个世界看起来就是下面这个样子：            那么，这个世界是确定的么？   首先，这个世界是有状态的，那些看起来存在y/n两个分支的节点，就存在于这种状态——选择还没有发生，就还有可能。   然而无论某一个节点的选择是什么，这个的世界的结果（的规模）是确定的，它必然演进到世界最下层中的状态的某一个。只不过这个最下层的规模足够大，所以在世界中的“未决”因素足够多的情况下，这个世界就看起来“">
    <meta name="twitter:url" content="http://aimingoo.github.io/1-196.html">
    <meta name="twitter:label1" content="Written by">
    <meta name="twitter:data1" content="aimingoo">
    <meta name="twitter:label2" content="Filed under">
    <meta name="twitter:data2" content="Javascript">
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "Aimingoo&#x27;s Blog",
        "logo": "http://aimingoo.github.io/content/images/2017/05/-----2017-05-06-12-31-48.png"
    },
    "author": {
        "@type": "Person",
        "name": "aimingoo",
        "image": {
            "@type": "ImageObject",
            "url": "http://aimingoo.github.io/content/images/2017/05/-----2017-05-06-12-23-58.png",
            "width": 944,
            "height": 858
        },
        "url": "http://aimingoo.github.io/author/aimingoo/",
        "sameAs": [
            "http://blog.csdn.net/aimingoo"
        ],
        "description": "I&#x27;m here."
    },
    "headline": "确定的世界 - The Promise&#x27;s World",
    "url": "http://aimingoo.github.io/1-196.html",
    "datePublished": "2015-08-10T09:35:00.000Z",
    "dateModified": "2017-05-19T18:28:14.000Z",
    "keywords": "Javascript",
    "description": "确定的世界 - The Promise’s World —— Promise的逻辑以及在Lua中的实现     本文基于如下项目(ES6 Promise in lua v1.0.1)：             https://github.com/aimingoo/Promise      有这样一个世界 有这样的一个世界在持续地向前推进着，这个世界充满着无穷多个选择，也就是说有无穷多的可能；但对每一个选择来说，存在决定/未决两种状态，如果已经决定，则只能有yes/no两种结果之一。这个世界看起来就是下面这个样子：            那么，这个世界是确定的么？   首先，这个世界是有状态的，那些看起来存在y/n两个分支的节点，就存在于这种状态——选择还没有发生，就还有可能。   然而无论某一个节点的选择是什么，这个的世界的结果（的规模）是确定的，它必然演进到世界最下层中的状态的某一个。只不过这个最下层的规模足够大，所以在世界中的“未决”因素足够多的情况下，这个世界就看起来“",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://aimingoo.github.io"
    }
}
    </script>

    <script type="text/javascript" src="shared/ghost-url.js?v=d1e3b9c792"></script>
<script type="text/javascript">
ghost.init({
	clientId: "ghost-frontend",
	clientSecret: "cb6d9de116b8"
});
</script>
    <meta name="generator" content="Ghost 0.11">
    <link rel="alternate" type="application/rss+xml" title="Aimingoo's Blog" href="rss/index.rss">
</head>

<body class="post-template tag-javascript nav-closed" data-spy="scroll" data-target="#tocScrollspy">

    <div class="site-wrapper">


        


<script type="text/javascript" author="aimingoo" src="assets/js/author-switcher.js?v=d1e3b9c792"></script>

<header class="main-header">
    <nav class="container main-nav clearfix">
        <div class="main-nav-title pull-left">
            <script>
            var titleTextInBody = '<a class="blog-title" href="index.html">Aimingoo&#x27;s Blog</a>';
            var theAuthor = {slug: 'aimingoo', url: '/author/aimingoo/'};
            if (theAuthor.slug == 'joyxhy') {
                titleTextInBody = '<' + 'a class="blog-title" hr' + 'ef="' + theAuthor.url + '">麦秸的垛</a>';
            }
            document.writeln(titleTextInBody);
            </script>
        </div>
            <div class="nav pull-right">
    <ul>
            <li class="nav-" role="presentation"><a href="index.html">首页</a></li>
            <li class="nav-" role="presentation"><a href="archives-post/">历史</a></li>
            <li class="nav-" role="presentation"><a href="about.html">关于</a></li>
    </ul>
</div>

    </nav>
</header>

<main id="container" class="container" role="main">
    <div id="content" class="content col-sm-12 col-md-8 col-lg-8">
        <article class="post tag-javascript">
            <header class="post-header">
                <h1 class="post-title"><a href="1-196.html">确定的世界 - The Promise's World</a></h1>
                <section class="post-meta">
                    <span class="post-meta-item">
                        <i class="fa fa-user"></i>
                        <a href="author/aimingoo/">aimingoo</a>
                    </span>
                    <span class="post-meta-item">
                        <i class="fa fa-clock-o"></i>
                        <time class="post-date" datetime="2015-08-10">2 years ago</time>
                        <time class="post-date" datetime="2015-08-10">(2015-08-10)</time>
                    </span>
                    <span class="post-meta-item post-meta-tags">
                        <i class="fa fa-tag"></i>
                        <a href="tag/javascript/">Javascript</a>
                    </span>
                    <span class="post-meta-item pull-right">
                        
                    </span>
                </section>
            </header>

            <section class="post-content">
                <h1 id="thepromisesworld">确定的世界 - The Promise’s World</h1>

<p>—— Promise的逻辑以及在Lua中的实现  </p>

<blockquote>
  <p>本文基于如下项目(ES6 Promise in lua v1.0.1)：  </p>
  
  <blockquote>
    <p><a href="https://github.com/aimingoo/Promise">https://github.com/aimingoo/Promise</a>  </p>
  </blockquote>
</blockquote>

<h2 id="">有这样一个世界</h2>

<p>有这样的一个世界在持续地向前推进着，这个世界充满着无穷多个选择，也就是说有无穷多的可能；但对每一个选择来说，存在决定/未决两种状态，如果已经决定，则只能有yes/no两种结果之一。这个世界看起来就是下面这个样子：     </p>

<p><img src="http://img.blog.csdn.net/20150810174734751" alt="The Promise" title="">     </p>

<p>那么，这个世界是确定的么？  </p>

<p>首先，这个世界是有状态的，那些看起来存在y/n两个分支的节点，就存在于这种状态——选择还没有发生，就还有可能。  </p>

<p>然而无论某一个节点的选择是什么，这个的世界的结果（的规模）是确定的，它必然演进到世界最下层中的状态的某一个。只不过这个最下层的规模足够大，所以在世界中的“未决”因素足够多的情况下，这个世界就看起来“一切皆有可能”而已。  </p>

<p>而这也就是Promise’s World，确定的世界。  </p>

<h2 id="">什么是已决定的？</h2>

<p>到底什么是已“确定”的呢？当你举起手枪对着自己的头的时候，这个行为是“确定”的吗？  </p>

<p>答案是：这个行为是“确定”的，你只是没有“决定”而已。这个称为“用枪瞄准自己的头”的系统很确定：要么是死，要么是不死——死或不死都是确定的。在语言中，你可以理解为：布尔值是确定的值，它确定的是yes/no。  </p>

<p>布尔值被理解为一个“已决定（它的结果行为）的”系统。同理，所有值类型的数据，所有有已决定结果的数据，都是确定的。这在promise中被这样定义下来：  </p>

<pre><code class="language-lua">local function promised_y(self, onFulfilled)  
    -- ...
end

-- ...

-- promise for basetype
local number_promise = setmetatable({andThen = promised_y}, promise)  
local true_promise   = setmetatable({andThen = promised_y, true}, promise)  
local false_promise  = setmetatable({andThen = promised_y, false}, promise)  
number_promise.__index = number_promise  
nil_promise.andThen = promised_y  
</code></pre>

<p>Ok，这里的代码的意思是说，number/string/boolean，以及nil这些值的行为(andThen)都是已决定的，指向promised_y()。  </p>

<blockquote>
  <p>javascript的promise规范中，这里被称为.then()方法，而拥有这样一个方法的对象被称为thenable object。这个方法有确定的接口：  </p>
  
  <blockquote>
    <p>function (onFulfilled, onRejected)  </p>
  </blockquote>
  
  <p>但在lua中由于then是保留字，所以只好用andThen作为方法名（也有用next来作为方法名的）。  </p>
</blockquote>

<p>同样，一个对象(lua中的table)也是已决定的，在promise中它与一般的value并没有不同。因此，在lua中的Promise.resolve(value)实现为如下：  </p>

<pre><code>function Promise.resolve(value)  
    local valueType = type(value)
    if valueType == 'nil' then
        return nil_promise
    elseif valueType == 'boolean' then
        return value and true_promise or false_promise
    elseif valueType == 'number' then
        return setmetatable({(value)}, number_promise)
    elseif valueType == 'string' then
        return value
    elseif (valueType == 'table') and (value.andThen ~= nil) then
        return value.catch ~= nil and value -- or, we can direct return value
            or setmetatable({catch=promise.catch}, {__index=value})
    else
        return setmetatable({andThen=promised_y, value}, promise)
    end
end  
</code></pre>

<p>留意这里的string类型，它与其它value略有区别，是因为string类型在lua中正好是有meta type的，因此可以直接通过修改元表来让它“变得与promise object”行为一样。至于其它，就必须包装一下了。  </p>

<blockquote>
  <p>对于对象(object/table)来说，它可能有三种情况：  </p>
  
  <blockquote>
    <ul>
    <li>如果为thenable object（即，有.andThen而没有.catch方法），则给他一个catch()方法；  </li>
    <li>如果为promise object，则直接返回；  </li>
    <li>如果为普通object（即，其它样式的lua table），则包装成promise object并返回。  </li>
    </ul>
  </blockquote>
</blockquote>

<p>那么，什么是promise object呢？  </p>

<h2 id="promiseobjectandpromiseclass">promise object and Promise class</h2>

<p>按照协议，promise框架必须实现promise object和Promise class。参考：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">ECMAScript 2015(ES6)</a>，包括如下这些类方法：  </p>

<blockquote>
  <p>Promise.new(func)     </p>
  
  <p>Promise.resolve(value)     </p>
  
  <p>Promise.reject(reason)     </p>
  
  <p>Promise.all(arr)     </p>
  
  <p>Promise.race(arr)  </p>
</blockquote>

<p>以及对象方法：  </p>

<blockquote>
  <p>promise:andThen(onFulfilled, onRejected)     </p>
  
  <p>Promise:catch(onRejected)  </p>
</blockquote>

<p>五种类方法之任一都将得到一个promise object。确切地说，你也只能通过这五种方法来得到promise object，哪怕只是数字1，也应当这样来写：  </p>

<pre><code class="language- lua">local promise_number_1 = Promise.resolve(1)  
</code></pre>

<p>这些类方法有些“潜在的/隐式地”将值变成promise的能力，例如：  </p>

<blockquote>
  <p>Promise.all(arr)  </p>
</blockquote>

<p>严格地来说all()要处理的是一个promise object array，为了这个目的，事实上它会将arr中的每个成员都尝试转换(resolve)以得到promise object。因此下面两种方法：  </p>

<pre><code class="language- lua">Promise.all([1,2,3]):andThen(..)  
-- vs.
Promise.all([  
    Promise.resolve(1),
    Promise.resolve(2),
    Promise.resolve(3)
]):andThen(..)
</code></pre>

<p>事实上是一样的效果。  </p>

<p>而具体到一个promise object，它在lua中描述的结构是一个table(array)。初始化时，它只有一个元素（我通常称之为p[1]）：  </p>

<blockquote>
  <p>a_promise_instance = { PENDING }  </p>
</blockquote>

<p>PENDING表明这个promise是未决的。如果已决定，例如上面提到过的“所有的”值，那么p[1]就存放的是那个具体的值。例如：  </p>

<pre><code class="language- lua">-- boolean promise object
{true}, {false}
-- number promise object
{1}, {1.23}, ..
-- object promise object
{{}}, {obj}, ..
-- userdata/function/coroutine/..
{userdata}, {func}, {co}, ..
-- nil promise object
{}
-- string is string, ^^.
'abcd'  
-- non-promised promise object
{PENDING}
</code></pre>

<p>在5种Promise类方法中，promise.resolve()和reject()得到的是一个已决定的、值的promise对象（或者，当传入promise object时，返回的是它自身，注1）。而其它三种方法，得到的都将是一个non-promised的对象——也就是说，这些情况下p[1]存放的是PENDING。  </p>

<blockquote>
  <p>注1: 在JavaScript中，这种情况仍将得到一个新的promise，而lua中得到传的的promise object。这并不会带来使用效果上的差异。  </p>
</blockquote>

<h2 id="lazyresolver">推迟决策：lazy resolver</h2>

<p>到目前为止，在我们具体讨论PENDING之前，所谓的promise object，以及整个的promise’s world其实都很简单。但仔细看去，这也不过是最开始所描绘的世界中左边的那一半而已——这一半都是promised，是确知的，已决定的。  </p>

<p>整个Promise世界的秘密(或魔法、活力)都在右边那一部分。也就是p[1]中写着PENDING的未决的那些结点。这些结点是推迟决策的，它什么时候到来是未知的，由于状态未决，所以也有不可确知的结果。仍然以那把瞄着你的头的枪为例，板机并不是你在扣着，而是在1公里以外的一个狙击手的手上。现在（当下）的问题是，你处于PENDING状态，既不知道那个狙击手是不是已经被第三者干掉了，还是已经扣下了板机而子弹是在飞过来的路上。PENDING这个状态是未决的，它未决的是你的生死，直到p[1]被填上一个值——如同子弹真正地射入你的头脑，或者邦德站在你的面前告诉你说“他死了”。  </p>

<p>p[1]将被填入“射击”这个行为发生的结果(value/result)，或这个行为没有发生的原因(reson)。无论二者之一为何，这个p[1]都是你现在（当下）所不确知的，所以尽管我们有千般主意，也只能等待value/reson两种结果被确认。这“千般主意”我们都可以一一想好，并且用promise:andThen()关联给这个promise，但……我们就是得等着结果发生。所以，Promise in lua为此设计了lazy对象，每一个用andThen添加进来的“主意”都是一个lazy，被追加到promise object数组的末尾——好的，我想你已经知道了，就是p[2]..p[n]，或称之p[2..n]。  </p>

<p>p[2..n]是一个个独立的lazy object。每个lazy表达为三个元素的数组：  </p>

<blockquote>
  <p>{promise, onFulfilled, onRejected}  </p>
</blockquote>

<p>由于一个PENDING promise是未决的，所以当它决定时至少要做的（第一个） 行为就是将真正的结果填入p[1]。所以由new/all/race这三种方法来创建的（未决的）promise的内部都会调用resolver()来实施这一决策：  </p>

<pre><code class="language- lua">function Promise.all(arr)  
    local this, result, count = setmetatable({PENDING}, promise), {}, #arr

    -- ...
    resolver(this, result, sure)
    -- ...
end

function Promise.race(arr)  
    local this, result, count = setmetatable({PENDING}, promise), {}, #arr

    -- ...
    resolver(this, result, sure)
    -- ...
end

function Promise.new(func)  
    local this = setmetatable({PENDING}, promise)
    pcall(func,
        function(value) return resolver(this, value, true) end,
        function(reason) return resolver(this, reason, false) end)
    -- ...
end  
</code></pre>

<p>而这里的“决策（resolver）”，不过是对确定的结果(value)采用确定的行为——将p[1]赋值，并重置andThen()方法：  </p>

<pre><code class="language- lua">local function resolver(this, resolved, sure)  
    -- ...
        this[1], this.andThen = resolved, sure and promised_y or promised_n
    -- ...
end  
</code></pre>

<p>以及推进所有p[2..n]中的行为：  </p>

<pre><code class="language- lua">local function resolver(this, resolved, sure)  
    -- ...
        for i, lazy in next, this, 1 do     -- 2..n
            pcall(resolver, lazy[1], promised(resolved, (sure and lazy[2] or lazy[3])), sure)
            this[i] = nil
        end
    -- ...
</code></pre>

<p>而已。然而考虑到promise规范中允许andThen()返回一个non-promised的promise object，因此resolver()将检测这种状态，并将与这个promise object对应的lazy添加到尾部。  </p>

<h2 id="promised">最后的promised</h2>

<p>现在，promise’s world中的结点要么是已决的(promised promise)。这种情况下它可能是一个一般值转换过来(Promise.resolve)的，因而只有左侧的边(promise<em>y)，也可能是一个promised promise object，因此具有两条边之一。无论如何，这样的一个promise object的p[1]存放着确定的值(value)，而andThen()指向一个确定有结果的行为：promised</em>y、promised<em>n，或promised</em>s。而这三个行为都必然是最终确定的：promised()  </p>

<pre><code class="language- lua">local function promised(value, action)  
    local ok, result = pcall(action, value)
    return ok and Promise.resolve(result) or Promise.reject(result)
end

local function promised_s(self, onFulfilled)  
    return onFulfilled and promised(self, onFulfilled) or self
end

local function promised_y(self, onFulfilled)  
    return onFulfilled and promised(self[1], onFulfilled) or self
end

local function promised_n(self, _, onRejected)  
    return onRejected and promised(self[1], onRejected) or self
end  
</code></pre>

<p>要么，就是还未决定的(non-promised promise)。因此它的p[1]中写着PENDING，andThen()指向一个将一切未知塞到p[2..n]的函数——既不是左边的y，也不是右边的n。  </p>

<p>而这，就是promise’s world的全部了：  </p>

<blockquote>
  <p>做你所决定的，为那些你所不能决定的做准备。  </p>
</blockquote>

<p>这一切，要等到PENDING发生变化，推迟决策生效（resolver过程启动）时才会有结果——所以resolver()函数是唯一在yes/no之外，你能看到有promised()调用的地方，那是未来将会发生的一次promised。一旦发生，non-promised was promised。  </p>

<h2 id="">示例</h2>

<p>有一个简单的示例，然而绝大多数lua promise框架都run不过。试试看吧：  </p>

<pre><code class="language-lua">---
-- A完成后，根据a做BCD三件事，再根据BCD的结果做E。
---

Promise = require('Promise')

A = function() return 10 end  
B = function(a) print(a * 2) end  
C = function(a)  
    print(a * 4)
    return Promise.resolve('ok')
end  
D = function(a) print(a * 3) end  
E = function(result)  
    local b, c, d = unpack(result)
    print(b, c, d)
    return Promise.reject('FIRE')
end

-- promise_A = Promise.resolve(A())
promise_A = Promise.new(function(resolve, reject)  
    local ok, result = pcall(A)
    return (ok and resolve or reject)(result)
end)  
promise_B = promise_A:andThen(B)  
promise_C = promise_A:andThen(C)  
promise_D = promise_A:andThen(D)

promises = {promise_B, promise_C, promise_D}  
Promise.all(promises)  
    :andThen(E)
    :catch(function(reson)
        print(reson)
    end)
</code></pre>
            </section>
<!-- removed by aimingoo
            <footer class="post-footer">
                {-{!> "post_author"}}
            </footer>
-->
        </article>

        <aside class="post-nav">
            <span class="post-nav-prev">
                上一篇
                <a href="1-195.html">
                    前端要给力之：红绿灯大战中的火星生命-Promise
                </a>
            </span>

            <span class="post-nav-next">
                <a href="1-1718.html">
                    再一次开始更新博客
                </a>
                下一篇
            </span>
        </aside>

        <section class="post comments">
<div id="gitment-root"></div>

<link rel="stylesheet" type="text/css" href="assets/css/gitment.default.css?v=d1e3b9c792">
<script src="assets/js/gitment.browser.js?v=d1e3b9c792"></script>

<script type="text/javascript">
	var SHORT_ID = function(url) { return url.replace(/\?.*$/, '').replace(/^.*\/|.html$/g, '') };
	var gitment = new Gitment({
	  id: SHORT_ID(location.href),
	  owner: 'aimingoo',
	  repo: 'aimingoo.github.io',
	  oauth: { client_id: 'c1285a991ba7db5c395a' }
	});
	gitment.render('gitment-root');
</script>
<noscript>Please enable JavaScript to view theses comments.</noscript>
</section>    </div>
    <div id="sidebar" class="sidebar col-md-4 col-lg-4">

            <div class="widget widget-profile">
        <div class="widget-profile-cover overlay no-cover"></div>
        <div class="widget-profile-header">
            <a class="widget-profile-logo" href="author/aimingoo/">
                <img src="content/images/2017/05/-----2017-05-06-12-23-58.png" alt="Aimingoo's Blog">
            </a>
        </div>
        <span class="widget-profile-title label label-xlg label-minty arrowed-in arrowed-in-right">aimingoo</span>
        <hr>
        <p class="widget-profile-desc">
                I'm here.
        </p>
        <hr>
        <!-- replaced by aimingoo -->
        <script type="text/javascript" src="profile-aimingoo"></script>
    </div>


<!-- replaced by aimingoo
    {-{> "tag_cloud"}}
-->
        <script type="text/javascript" author="aimingoo" src="tag-cloud"></script>

        <div class="widget widget-toc">
    <div class="widget-title">
        <div class="widget-title-meta">
            <i class="fa fa-list-ul"></i> 
            <span class="title-meta-word">文章目录</span>
        </div>
    </div>
    <nav id="tocScrollspy">
        <ul id="toc" class="toc"></ul>
    </nav>
</div>
</div>
</main>


        <footer class="site-footer clearfix">
            <div class="footer-meta container">
                <section class="copyright"><a href="index.html">Aimingoo's Blog</a> © 2017</section>
                <section class="poweredby">Proudly published with <a href="https://ghost.org">Ghost</a>, Theme <a href="https://github.com/xiaoluoboding/kaldorei">Kaldorei</a></section>
            </div>
        </footer>

    </div>

    <div id="backTop" class="backTop">
        <button class="btn btn-inverse">
            <i class="fa fa-chevron-up"></i>
        </button>
    </div>

    <script type="text/javascript" src="assets/js/jquery-1.12.0.min.js?v=d1e3b9c792"></script>
    

    <script type="text/javascript" src="assets/js/jquery.fitvids.js?v=d1e3b9c792"></script>
    <script type="text/javascript" src="assets/js/index.js?v=d1e3b9c792"></script>
    <script type="text/javascript" src="assets/plugins/bootstrap-3.3.5/js/bootstrap.min.js?v=d1e3b9c792"></script>
    <script type="text/javascript" src="assets/plugins/highlight-9.1.0/highlight.pack.js?v=d1e3b9c792"></script>
    <script type="text/javascript" src="assets/plugins/jquery-toc-0.3.5/jquery.toc.js?v=d1e3b9c792"></script>
    <script type="text/javascript" src="assets/plugins/velocity-1.2.3/velocity.min.js?v=d1e3b9c792"></script>
    <script type="text/javascript" src="assets/plugins/velocity-1.2.3/velocity.ui.min.js?v=d1e3b9c792"></script>
    <script type="text/javascript" src="assets/plugins/anijs-0.9.3/anijs-min.js?v=d1e3b9c792"></script>
    <script type="text/javascript" src="assets/plugins/anijs-0.9.3/anijs-helper-scrollreveal-min.js?v=d1e3b9c792"></script>
    <script type="text/javascript" src="assets/plugins/github-repo-jquery-widget/jquery.githubRepoWidget.min.js?v=d1e3b9c792"></script>
    <script type="text/javascript" src="assets/plugins/fancybox-2.1.5/jquery.fancybox.pack.js?v=d1e3b9c792"></script>
</body>


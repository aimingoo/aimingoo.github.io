<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>确定的世界 - The Promise&#x27;s World</title>

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="/favicon.png">
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />
    <!-- <link rel="stylesheet" type="text/css" href="//fonts.useso.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" /> -->
    <link rel="stylesheet" type="text/css" href="/assets/plugins/font-awesome-4.5.0/css/font-awesome.min.css" />
    <link rel="stylesheet" type="text/css" href="/assets/plugins/bootstrap-3.3.5/css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="/assets/plugins/highlight-9.1.0/styles/xcode.css" />
    <link rel="stylesheet" type="text/css" href="/assets/plugins/anijs-0.9.3/anicollection.min.css" />
    <link rel="stylesheet" type="text/css" href="/assets/plugins/fancybox-2.1.5/jquery.fancybox.css" />
    <link rel="shortcut icon" href="/favicon.png" type="image/png" />
    <meta name="referrer" content="no-referrer-when-downgrade" />
    
    <meta property="og:site_name" content="Aimingoo&#x27;s Blog" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="确定的世界 - The Promise&#x27;s World" />
    <meta property="og:description" content="确定的世界 - The Promise’s World —— Promise的逻辑以及在Lua中的实现 本文基于如下项目(ES6 Promise in lua v1.0.1)： https://github.com/aimingoo/Promise 有这样一个世界 有这样的一个世界在持续地向前推进着，这个世界充满着无穷多个选择，也就是说有无穷多的可能；但对每一个选择来说，存在决定/未决两种状态，如果已经决定，则只能有yes/no两种结果之一。这个世界看起来就是下面这个样子： 那么，这个世界是确定的么？ 首先，这个世界是有状态的，那些看起来存在y/n两个分支的节点，就存在于这种状态——选择还没有发生，就还有可能。 然而无论某一个节点的选择是什么，这个的世界的结果（的规模）是确定的，它必然演进到世界最下层中的状态的某一个。只不过这个最下层的规模足够大，所以在世界中的“未决”因素足够多的情况下，这个世界就看起来“" />
    <meta property="og:url" content="https://aimingoo.github.io/1-196.html" />
    <meta property="article:published_time" content="2015-08-10T09:35:00.000Z" />
    <meta property="article:modified_time" content="2017-10-15T08:22:56.000Z" />
    <meta property="article:tag" content="Javascript" />
    <meta property="article:tag" content="Promise" />
    <meta property="article:tag" content="OpenSource Project" />
    
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="确定的世界 - The Promise&#x27;s World" />
    <meta name="twitter:description" content="确定的世界 - The Promise’s World —— Promise的逻辑以及在Lua中的实现 本文基于如下项目(ES6 Promise in lua v1.0.1)： https://github.com/aimingoo/Promise 有这样一个世界 有这样的一个世界在持续地向前推进着，这个世界充满着无穷多个选择，也就是说有无穷多的可能；但对每一个选择来说，存在决定/未决两种状态，如果已经决定，则只能有yes/no两种结果之一。这个世界看起来就是下面这个样子： 那么，这个世界是确定的么？ 首先，这个世界是有状态的，那些看起来存在y/n两个分支的节点，就存在于这种状态——选择还没有发生，就还有可能。 然而无论某一个节点的选择是什么，这个的世界的结果（的规模）是确定的，它必然演进到世界最下层中的状态的某一个。只不过这个最下层的规模足够大，所以在世界中的“未决”因素足够多的情况下，这个世界就看起来“" />
    <meta name="twitter:url" content="https://aimingoo.github.io/1-196.html" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="aimingoo" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="Javascript, Promise, OpenSource Project" />
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "Aimingoo&#x27;s Blog",
        "logo": "https://aimingoo.github.io/content/images/2017/05/-----2017-05-06-12-31-48.png"
    },
    "author": {
        "@type": "Person",
        "name": "aimingoo",
        "image": {
            "@type": "ImageObject",
            "url": "https://aimingoo.github.io/content/images/2017/10/IMG_5559-1.jpg",
            "width": 128,
            "height": 128
        },
        "url": "https://aimingoo.github.io/author/aimingoo/",
        "sameAs": []
    },
    "headline": "确定的世界 - The Promise&#x27;s World",
    "url": "https://aimingoo.github.io/1-196.html",
    "datePublished": "2015-08-10T09:35:00.000Z",
    "dateModified": "2017-10-15T08:22:56.000Z",
    "keywords": "Javascript, Promise, OpenSource Project",
    "description": "确定的世界 - The Promise’s World —— Promise的逻辑以及在Lua中的实现 本文基于如下项目(ES6 Promise in lua v1.0.1)： https://github.com/aimingoo/Promise 有这样一个世界 有这样的一个世界在持续地向前推进着，这个世界充满着无穷多个选择，也就是说有无穷多的可能；但对每一个选择来说，存在决定/未决两种状态，如果已经决定，则只能有yes/no两种结果之一。这个世界看起来就是下面这个样子： 那么，这个世界是确定的么？ 首先，这个世界是有状态的，那些看起来存在y/n两个分支的节点，就存在于这种状态——选择还没有发生，就还有可能。 然而无论某一个节点的选择是什么，这个的世界的结果（的规模）是确定的，它必然演进到世界最下层中的状态的某一个。只不过这个最下层的规模足够大，所以在世界中的“未决”因素足够多的情况下，这个世界就看起来“",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://aimingoo.github.io/"
    }
}
    </script>

    <script type="text/javascript" src="/public/ghost-sdk.min.js"></script>
<script type="text/javascript">
ghost.init({
	clientId: "ghost-frontend",
	clientSecret: "e8bc7646b93e"
});
</script>
    <meta name="generator" content="Ghost 1.14" />
    <link rel="alternate" type="application/rss+xml" title="Aimingoo&#x27;s Blog" href="https://aimingoo.github.io/rss/" />
</head>

<body class="post-template tag-javascript tag-promise tag-opensource-project nav-closed" data-spy="scroll" data-target="#tocScrollspy">

    <div class="site-wrapper">

        


<header class="main-header">
    <nav class="container main-nav clearfix">
        <div class="main-nav-title pull-left">
            <script>
            var titleTextInBody = '<a class="blog-title" href="https://aimingoo.github.io">Aimingoo&#x27;s Blog</a>';
            var theAuthor = {slug: 'aimingoo', url: '/author/aimingoo/'};
            if (theAuthor.slug == 'joyxhy') {
                titleTextInBody = '<' + 'a class="blog-title" hr' + 'ef="' + theAuthor.url + '">麦秸的垛</a>';
            }
            document.writeln(titleTextInBody);
            </script>
        </div>
            <div class="nav pull-right">
    <ul>
            <li class="nav-" role="presentation"><a href="https://aimingoo.github.io/">首页</a></li>
            <li class="nav-" role="presentation"><a href="https://aimingoo.github.io/author/joyxhy/">麦秸的垛</a></li>
            <li class="nav-" role="presentation"><a href="https://aimingoo.github.io/archives-post/">历史</a></li>
            <li class="nav-" role="presentation"><a href="https://aimingoo.github.io/about/">关于</a></li>
    </ul>
</div>

    </nav>
</header>

<script type="text/javascript" author="aimingoo" src="/assets/js/author-switcher.js"></script>

<main id="container" class="container" role="main">
    <div id="content" class="content col-sm-12 col-md-8 col-lg-8">
        <article class="post tag-javascript tag-promise tag-opensource-project">
            <header class="post-header">
                <h1 class="post-title u-aimingoo"><a href="/1-196.html">确定的世界 - The Promise&#x27;s World</a></h1>
                <section class="post-meta">
                    <span class="post-meta-item">
                        <i class="fa fa-user"></i>
                        <a href="/author/aimingoo/">aimingoo</a>
                    </span>
                    <span class="post-meta-item">
                        <i class="fa fa-clock-o"></i>
                        <time class="post-date" datetime="2015-08-10T17:35:00.000+08:00" timeago="true"></time>
                        <time class="post-date" datetime="2015-08-10">(2015-08-10)</time>
                    </span>
                    <span class="post-meta-item post-meta-tags">
                        <i class="fa fa-tag"></i>
                        <a href="/tag/javascript/">Javascript</a>, <a href="/tag/promise/">Promise</a>, <a href="/tag/opensource-project/">OpenSource Project</a>
                    </span>
                    <span class="post-meta-item pull-right">
                        
                    </span>
                </section>
            </header>

            <section class="post-content">
                <div class="kg-card-markdown"><h1 id="thepromisesworld">确定的世界 - The Promise’s World</h1>
<p>—— Promise的逻辑以及在Lua中的实现</p>
<blockquote>
<p>本文基于如下项目(ES6 Promise in lua v1.0.1)：</p>
<blockquote>
<p><a href="https://github.com/aimingoo/Promise">https://github.com/aimingoo/Promise</a></p>
</blockquote>
</blockquote>
<h2 id="">有这样一个世界</h2>
<p>有这样的一个世界在持续地向前推进着，这个世界充满着无穷多个选择，也就是说有无穷多的可能；但对每一个选择来说，存在决定/未决两种状态，如果已经决定，则只能有yes/no两种结果之一。这个世界看起来就是下面这个样子：</p>
<p><img src="/content/images/2017/10/20150810174734751.png" alt=""></p>
<p>那么，这个世界是确定的么？</p>
<p>首先，这个世界是有状态的，那些看起来存在y/n两个分支的节点，就存在于这种状态——选择还没有发生，就还有可能。</p>
<p>然而无论某一个节点的选择是什么，这个的世界的结果（的规模）是确定的，它必然演进到世界最下层中的状态的某一个。只不过这个最下层的规模足够大，所以在世界中的“未决”因素足够多的情况下，这个世界就看起来“一切皆有可能”而已。</p>
<p>而这也就是Promise’s World，确定的世界。</p>
<h2 id="">什么是已决定的？</h2>
<p>到底什么是已“确定”的呢？当你举起手枪对着自己的头的时候，这个行为是“确定”的吗？</p>
<p>答案是：这个行为是“确定”的，你只是没有“决定”而已。这个称为“用枪瞄准自己的头”的系统很确定：要么是死，要么是不死——死或不死都是确定的。在语言中，你可以理解为：布尔值是确定的值，它确定的是yes/no。</p>
<p>布尔值被理解为一个“已决定（它的结果行为）的”系统。同理，所有值类型的数据，所有有已决定结果的数据，都是确定的。这在promise中被这样定义下来：</p>
<pre><code class="language-lua">local function promised_y(self, onFulfilled)
    -- ...
end

-- ...

-- promise for basetype
local number_promise = setmetatable({andThen = promised_y}, promise)
local true_promise   = setmetatable({andThen = promised_y, true}, promise)
local false_promise  = setmetatable({andThen = promised_y, false}, promise)
number_promise.__index = number_promise
nil_promise.andThen = promised_y
</code></pre>
<p>Ok，这里的代码的意思是说，number/string/boolean，以及nil这些值的行为(andThen)都是已决定的，指向promised_y()。</p>
<blockquote>
<p>javascript的promise规范中，这里被称为.then()方法，而拥有这样一个方法的对象被称为thenable object。这个方法有确定的接口：</p>
<blockquote>
<p>function (onFulfilled, onRejected)</p>
</blockquote>
<p>但在lua中由于then是保留字，所以只好用andThen作为方法名（也有用next来作为方法名的）。</p>
</blockquote>
<p>同样，一个对象(lua中的table)也是已决定的，在promise中它与一般的value并没有不同。因此，在lua中的Promise.resolve(value)实现为如下：</p>
<pre><code>function Promise.resolve(value)
    local valueType = type(value)
    if valueType == 'nil' then
        return nil_promise
    elseif valueType == 'boolean' then
        return value and true_promise or false_promise
    elseif valueType == 'number' then
        return setmetatable({(value)}, number_promise)
    elseif valueType == 'string' then
        return value
    elseif (valueType == 'table') and (value.andThen ~= nil) then
        return value.catch ~= nil and value -- or, we can direct return value
            or setmetatable({catch=promise.catch}, {__index=value})
    else
        return setmetatable({andThen=promised_y, value}, promise)
    end
end
</code></pre>
<p>留意这里的string类型，它与其它value略有区别，是因为string类型在lua中正好是有meta type的，因此可以直接通过修改元表来让它“变得与promise object”行为一样。至于其它，就必须包装一下了。例如对于对象(object/table)来说，就可能有三种情况：</p>
<blockquote>
<ul>
<li>如果为thenable object（即，有.andThen而没有.catch方法），则给他一个catch()方法；</li>
<li>如果为promise object，则直接返回；</li>
<li>如果为普通object（即，其它样式的lua table），则包装成promise object并返回。</li>
</ul>
</blockquote>
<p>那么，什么是promise object呢？</p>
<h2 id="promiseobjectandpromiseclass">promise object and Promise class</h2>
<p>按照协议，promise框架必须实现promise object和Promise class。参考：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">ECMAScript 2015(ES6)</a>，包括如下这些类方法：</p>
<blockquote>
<p>Promise.new(func)</p>
<p>Promise.resolve(value)</p>
<p>Promise.reject(reason)</p>
<p>Promise.all(arr)</p>
<p>Promise.race(arr)</p>
</blockquote>
<p>以及对象方法：</p>
<blockquote>
<p>promise:andThen(onFulfilled, onRejected)</p>
<p>Promise:catch(onRejected)</p>
</blockquote>
<p>五种类方法之任一都将得到一个promise object。确切地说，你也只能通过这五种方法来得到promise object，哪怕只是数字1，也应当这样来写：</p>
<pre><code class="language-lua">local promise_number_1 = Promise.resolve(1)
</code></pre>
<p>这些类方法有些“潜在的/隐式地”将值变成promise的能力，例如：</p>
<blockquote>
<p>Promise.all(arr)</p>
</blockquote>
<p>严格地来说all()要处理的是一个promise object array，为了这个目的，事实上它会将arr中的每个成员都尝试转换(resolve)以得到promise object。因此下面两种方法：</p>
<pre><code class="language-lua">Promise.all([1,2,3]):andThen(..)
-- vs.
Promise.all([
    Promise.resolve(1),
    Promise.resolve(2),
    Promise.resolve(3)
]):andThen(..)
</code></pre>
<p>事实上是一样的效果。</p>
<p>而具体到一个promise object，它在lua中描述的结构是一个table(array)。初始化时，它只有一个元素（我通常称之为p[1]）：</p>
<blockquote>
<p>a_promise_instance = { PENDING }</p>
</blockquote>
<p>PENDING表明这个promise是未决的。如果已决定，例如上面提到过的“所有的”值，那么p[1]就存放的是那个具体的值。例如：</p>
<pre><code class="language-lua">-- boolean promise object
{true}, {false}
-- number promise object
{1}, {1.23}, ..
-- object promise object
{{}}, {obj}, ..
-- userdata/function/coroutine/..
{userdata}, {func}, {co}, ..
-- nil promise object
{}
-- string is string, ^^.
'abcd'
-- non-promised promise object
{PENDING}
</code></pre>
<p>在5种Promise类方法中，promise.resolve()和reject()得到的是一个已决定的、值的promise对象（或者，当传入promise object时，返回的是它自身，注1）。而其它三种方法，得到的都将是一个non-promised的对象——也就是说，这些情况下p[1]存放的是PENDING。</p>
<blockquote>
<p>注1: 在JavaScript中，这种情况仍将得到一个新的promise，而lua中得到传的的promise object。这并不会带来使用效果上的差异。</p>
</blockquote>
<h2 id="lazyresolver">推迟决策：lazy resolver</h2>
<p>到目前为止，在我们具体讨论PENDING之前，所谓的promise object，以及整个的promise’s world其实都很简单。但仔细看去，这也不过是最开始所描绘的世界中左边的那一半而已——这一半都是promised，是确知的，已决定的。</p>
<p>整个Promise世界的秘密(或魔法、活力)都在右边那一部分。也就是p[1]中写着PENDING的未决的那些结点。这些结点是推迟决策的，它什么时候到来是未知的，由于状态未决，所以也有不可确知的结果。仍然以那把瞄着你的头的枪为例，板机并不是你在扣着，而是在1公里以外的一个狙击手的手上。现在（当下）的问题是，你处于PENDING状态，既不知道那个狙击手是不是已经被第三者干掉了，还是已经扣下了板机而子弹是在飞过来的路上。PENDING这个状态是未决的，它未决的是你的生死，直到p[1]被填上一个值——如同子弹真正地射入你的头脑，或者邦德站在你的面前告诉你说“他死了”。</p>
<p>p[1]将被填入“射击”这个行为发生的结果(value/result)，或这个行为没有发生的原因(reson)。无论二者之一为何，这个p[1]都是你现在（当下）所不确知的，所以尽管我们有千般主意，也只能等待value/reson两种结果被确认。这“千般主意”我们都可以一一想好，并且用promise:andThen()关联给这个promise，但……我们就是得等着结果发生。所以，Promise in lua为此设计了lazy对象，每一个用andThen添加进来的“主意”都是一个lazy，被追加到promise object数组的末尾——好的，我想你已经知道了，就是p[2]..p[n]，或称之p[2..n]。</p>
<p>p[2..n]是一个个独立的lazy object。每个lazy表达为三个元素的数组：</p>
<blockquote>
<p>{promise, onFulfilled, onRejected}</p>
</blockquote>
<p>由于一个PENDING promise是未决的，所以当它决定时至少要做的（第一个） 行为就是将真正的结果填入p[1]。所以由new/all/race这三种方法来创建的（未决的）promise的内部都会调用resolver()来实施这一决策：</p>
<pre><code class="language-lua">function Promise.all(arr)
    local this, result, count = setmetatable({PENDING}, promise), {}, #arr

    -- ...
    resolver(this, result, sure)
    -- ...
end

function Promise.race(arr)
    local this, result, count = setmetatable({PENDING}, promise), {}, #arr

    -- ...
    resolver(this, result, sure)
    -- ...
end

function Promise.new(func)
    local this = setmetatable({PENDING}, promise)
    pcall(func,
        function(value) return resolver(this, value, true) end,
        function(reason) return resolver(this, reason, false) end)
    -- ...
end
</code></pre>
<p>而这里的“决策（resolver）”，不过是对确定的结果(value)采用确定的行为——将p[1]赋值，并重置andThen()方法：</p>
<pre><code class="language-lua">local function resolver(this, resolved, sure)
    -- ...
        this[1], this.andThen = resolved, sure and promised_y or promised_n
    -- ...
end
</code></pre>
<p>以及推进所有p[2..n]中的行为：</p>
<pre><code class="language-lua">local function resolver(this, resolved, sure)
    -- ...
        for i, lazy in next, this, 1 do     -- 2..n
            pcall(resolver, lazy[1], promised(resolved, (sure and lazy[2] or lazy[3])), sure)
            this[i] = nil
        end
    -- ...
</code></pre>
<p>而已。然而考虑到promise规范中允许andThen()返回一个non-promised的promise object，因此resolver()将检测这种状态，并将与这个promise object对应的lazy添加到尾部。</p>
<h2 id="promised">最后的promised</h2>
<p>现在，promise’s world中的结点要么是已决的(promised promise)。这种情况下它可能是一个一般值转换过来(Promise.resolve)的，因而只有左侧的边(promise_y)，也可能是一个promised promise object，因此具有两条边之一。无论如何，这样的一个promise object的p[1]存放着确定的值(value)，而andThen()指向一个确定有结果的行为：promised_y、promised_n，或promised_s。而这三个行为都必然是最终确定的：promised()</p>
<pre><code class="language-lua">local function promised(value, action)
    local ok, result = pcall(action, value)
    return ok and Promise.resolve(result) or Promise.reject(result)
end

local function promised_s(self, onFulfilled)
    return onFulfilled and promised(self, onFulfilled) or self
end

local function promised_y(self, onFulfilled)
    return onFulfilled and promised(self[1], onFulfilled) or self
end

local function promised_n(self, _, onRejected)
    return onRejected and promised(self[1], onRejected) or self
end
</code></pre>
<p>要么，就是还未决定的(non-promised promise)。因此它的p[1]中写着PENDING，andThen()指向一个将一切未知塞到p[2..n]的函数——既不是左边的y，也不是右边的n。</p>
<p>而这，就是promise’s world的全部了：</p>
<blockquote>
<p>做你所决定的，为那些你所不能决定的做准备。</p>
</blockquote>
<p>这一切，要等到PENDING发生变化，推迟决策生效（resolver过程启动）时才会有结果——所以resolver()函数是唯一在yes/no之外，你能看到有promised()调用的地方，那是未来将会发生的一次promised。一旦发生，non-promised was promised。</p>
<h2 id="">示例</h2>
<p>有一个简单的示例，然而绝大多数lua promise框架都run不过。试试看吧：</p>
<pre><code class="language-lua">---
-- A完成后，根据a做BCD三件事，再根据BCD的结果做E。
---

Promise = require('Promise')

A = function() return 10 end
B = function(a) print(a * 2) end
C = function(a)
    print(a * 4)
    return Promise.resolve('ok')
end
D = function(a) print(a * 3) end
E = function(result)
    local b, c, d = unpack(result)
    print(b, c, d)
    return Promise.reject('FIRE')
end

-- promise_A = Promise.resolve(A())
promise_A = Promise.new(function(resolve, reject)
    local ok, result = pcall(A)
    return (ok and resolve or reject)(result)
end)
promise_B = promise_A:andThen(B)
promise_C = promise_A:andThen(C)
promise_D = promise_A:andThen(D)

promises = {promise_B, promise_C, promise_D}
Promise.all(promises)
    :andThen(E)
    :catch(function(reson)
        print(reson)
    end)
</code></pre>
</div>
            </section>
<!-- removed by aimingoo
            <footer class="post-footer">
                {-{!> "post_author"}}
            </footer>
-->
        </article>

        <aside class="post-nav">
            <span class="post-nav-prev">
                上一篇
                <a href="/1-195.html">
                    前端要给力之：红绿灯大战中的火星生命-Promise
                </a>
            </span>

            <span class="post-nav-next" >
                <a href="/59e2e9b272c9e7b37c3831f0.html">
                    深夜食味记之一：番茄鸡蛋汤
                </a>
                下一篇
            </span>
        </aside>
        <section class="post comments">
<div id="gitment-root"></div>

<link rel="stylesheet" type="text/css" href="/assets/css/gitment.default.css" />
<script src="/assets/js/gitmint.browser.js"></script>

<style>
a.gitment-editor-footer-tip { display: none; }
.gitment-container.gitment-footer-container { display: none; }
</style>

<script type="text/javascript">
	var SHORT_ID = function(url) { return url.replace(/[\?#].*$/, '').replace(/\/((default|index)\..{1,4})?$/,'').replace(/^.*\/|.html$/g, '') };
	var gitment = new Gitmint({
	  id: SHORT_ID(location.href),
	  owner: 'aimingoo',
	  repo: 'aimingoo.github.io',
	  lang: 'zh-CN'
	});
	gitment.render('gitment-root');
</script>
<noscript>Please enable JavaScript to view theses comments.</noscript>
</section>    </div>
    <div id="sidebar" class="sidebar col-md-4 col-lg-4">

            <div class="widget widget-profile">
        <div class="widget-profile-cover overlay " style="background-image: url(/content/images/2017/10/IMG_5294-1.jpg)"></div>
        <div class="widget-profile-header">
            <a class="widget-profile-logo" href="/author/aimingoo/">
                <img src="/content/images/2017/10/IMG_5559-1.jpg" alt="Aimingoo&#x27;s Blog" />
            </a>
        </div>
        <span class="widget-profile-title label label-xlg label-minty arrowed-in arrowed-in-right">aimingoo</span>
        <hr>
        <p class="widget-profile-desc">
                云色青青若醉，还与东湖寐
        </p>
        <hr>
        <!-- replaced by aimingoo -->
        <script type="text/javascript" src="/profile-aimingoo"></script>
    </div>


<!-- replaced by aimingoo
    {-{> "tag_cloud"}}
-->
        <script type="text/javascript" author="aimingoo" src="/tag-cloud"></script>

        <div class="widget widget-toc">
    <div class="widget-title">
        <div class="widget-title-meta">
            <i class="fa fa-list-ul"></i>&nbsp;
            <span class="title-meta-word">文章目录</span>
        </div>
    </div>
    <nav id="tocScrollspy">
        <ul id="toc" class="toc"></ul>
    </nav>
</div>
</div>
</main>


        <footer class="site-footer clearfix">
            <div class="footer-meta container">
                <section class="copyright"><a href="https://aimingoo.github.io">Aimingoo&#x27;s Blog</a> &copy; 2021</section>
                <section class="poweredby">Proudly published with <a href="https://ghost.org">Ghost</a>, Theme <a href="https://github.com/xiaoluoboding/kaldorei">Kaldorei</a></section>
            </div>
        </footer>

    </div>

    <div id="backTop" class="backTop">
        <button class="btn btn-inverse">
            <i class="fa fa-chevron-up"></i>
        </button>
    </div>

    <script type="text/javascript" src="/assets/js/jquery-1.12.0.min.js"></script>
    

    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="/assets/js/timeAgo.js"></script>
    <script type="text/javascript" src="/assets/js/index.js"></script>
    <script type="text/javascript" src="/assets/plugins/bootstrap-3.3.5/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/assets/plugins/highlight-9.1.0/highlight.pack.js"></script>
    <script type="text/javascript" src="/assets/plugins/jquery-toc-0.3.5/jquery.toc.js"></script>
    <script type="text/javascript" src="/assets/plugins/velocity-1.2.3/velocity.min.js"></script>
    <script type="text/javascript" src="/assets/plugins/velocity-1.2.3/velocity.ui.min.js"></script>
    <script type="text/javascript" src="/assets/plugins/anijs-0.9.3/anijs-min.js"></script>
    <script type="text/javascript" src="/assets/plugins/anijs-0.9.3/anijs-helper-scrollreveal-min.js"></script>
    <script type="text/javascript" src="/assets/plugins/github-repo-jquery-widget/jquery.githubRepoWidget.min.js"></script>
    <script type="text/javascript" src="/assets/plugins/fancybox-2.1.5/jquery.fancybox.pack.js"></script>
</body>

</html>

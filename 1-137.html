

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>表面的简洁</title>
    <meta name="description" content="">

    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="shortcut icon" href="favicon.ico">
    <link rel="stylesheet" type="text/css" href="assets/css/screen.css?v=8444992c76">
    <!-- <link rel="stylesheet" type="text/css" href="//fonts.useso.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" /> -->
    <link rel="stylesheet" type="text/css" href="assets/plugins/font-awesome-4.5.0/css/font-awesome.min.css?v=8444992c76">
    <link rel="stylesheet" type="text/css" href="assets/plugins/bootstrap-3.3.5/css/bootstrap.min.css?v=8444992c76">
    <link rel="stylesheet" type="text/css" href="assets/plugins/highlight-9.1.0/styles/monokai-sublime.css?v=8444992c76">
    <link rel="stylesheet" type="text/css" href="assets/plugins/anijs-0.9.3/anicollection.min.css?v=8444992c76">
    <link rel="stylesheet" type="text/css" href="assets/plugins/fancybox-2.1.5/jquery.fancybox.css?v=8444992c76">
    <meta name="referrer" content="no-referrer-when-downgrade">
    
    <meta property="og:site_name" content="Aimingoo's Blog">
    <meta property="og:type" content="article">
    <meta property="og:title" content="表面的简洁">
    <meta property="og:description" content="&amp;nbsp;      **本文刊发在《程序员》杂志09年第二期上。是讨论函数式语言基本性质和发展方向的一篇文章。 **      &amp;nbsp;   **表面的简洁**   一、把大象装进冰箱     ＝＝＝＝＝     　　在命令式语言（当然我们可以确指为C、Delphi、Java或C#等等）中，初学者的第一     个疑难便是这样的代码（*注1）：     　　X=X&amp;#43;1     　　为什么？因为在数学概念中，上述等式是不能成立的。这种表达式是计算机的思维逻     辑：当它运算上述表达式（或语句）时，X被作为暂存单元——例如冰箱。为了让冰箱产     生变化，比如解决“把大象装进冰箱”这样的问题，我们需要如下三步：     　　把冰箱门打开，把大象放进去，把冰箱门关上          （图1：“把大象装进冰箱”的问题）     　　因为我们有两只手来分别负责拉住冰箱门和大象，所以整个操作过程看起来很完美，     但接下来我们再加上点需求：我们要“把大象拿出来，把长颈鹿装进去”">
    <meta property="og:url" content="http://aimingoo.github.io/1-137.html">
    <meta property="article:published_time" content="2009-04-22T03:44:00.000Z">
    <meta property="article:modified_time" content="2009-04-22T03:44:00.000Z">
    <meta property="article:tag" content="Javascript">
    <meta property="article:tag" content="erlang">
    <meta property="article:tag" content="lisp">
    <meta property="article:tag" content="语言">
    <meta property="article:tag" content="delphi">
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="表面的简洁">
    <meta name="twitter:description" content="&amp;nbsp;      **本文刊发在《程序员》杂志09年第二期上。是讨论函数式语言基本性质和发展方向的一篇文章。 **      &amp;nbsp;   **表面的简洁**   一、把大象装进冰箱     ＝＝＝＝＝     　　在命令式语言（当然我们可以确指为C、Delphi、Java或C#等等）中，初学者的第一     个疑难便是这样的代码（*注1）：     　　X=X&amp;#43;1     　　为什么？因为在数学概念中，上述等式是不能成立的。这种表达式是计算机的思维逻     辑：当它运算上述表达式（或语句）时，X被作为暂存单元——例如冰箱。为了让冰箱产     生变化，比如解决“把大象装进冰箱”这样的问题，我们需要如下三步：     　　把冰箱门打开，把大象放进去，把冰箱门关上          （图1：“把大象装进冰箱”的问题）     　　因为我们有两只手来分别负责拉住冰箱门和大象，所以整个操作过程看起来很完美，     但接下来我们再加上点需求：我们要“把大象拿出来，把长颈鹿装进去”">
    <meta name="twitter:url" content="http://aimingoo.github.io/1-137.html">
    <meta name="twitter:label1" content="Written by">
    <meta name="twitter:data1" content="aimingoo">
    <meta name="twitter:label2" content="Filed under">
    <meta name="twitter:data2" content="Javascript, erlang, lisp, 语言, delphi">
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "Aimingoo&#x27;s Blog",
        "logo": "http://aimingoo.github.io/content/images/2017/05/-----2017-05-06-12-31-48.png"
    },
    "author": {
        "@type": "Person",
        "name": "aimingoo",
        "image": {
            "@type": "ImageObject",
            "url": "http://aimingoo.github.io/content/images/2017/05/-----2017-05-06-12-23-58.png",
            "width": 944,
            "height": 858
        },
        "url": "http://aimingoo.github.io/author/aimingoo/",
        "sameAs": [
            "http://blog.csdn.net/aimingoo"
        ],
        "description": "I&#x27;m here."
    },
    "headline": "表面的简洁",
    "url": "http://aimingoo.github.io/1-137.html",
    "datePublished": "2009-04-22T03:44:00.000Z",
    "dateModified": "2009-04-22T03:44:00.000Z",
    "keywords": "Javascript, erlang, lisp, 语言, delphi",
    "description": "&amp;nbsp;      **本文刊发在《程序员》杂志09年第二期上。是讨论函数式语言基本性质和发展方向的一篇文章。 **      &amp;nbsp;   **表面的简洁**   一、把大象装进冰箱     ＝＝＝＝＝     　　在命令式语言（当然我们可以确指为C、Delphi、Java或C#等等）中，初学者的第一     个疑难便是这样的代码（*注1）：     　　X&#x3D;X&amp;#43;1     　　为什么？因为在数学概念中，上述等式是不能成立的。这种表达式是计算机的思维逻     辑：当它运算上述表达式（或语句）时，X被作为暂存单元——例如冰箱。为了让冰箱产     生变化，比如解决“把大象装进冰箱”这样的问题，我们需要如下三步：     　　把冰箱门打开，把大象放进去，把冰箱门关上          （图1：“把大象装进冰箱”的问题）     　　因为我们有两只手来分别负责拉住冰箱门和大象，所以整个操作过程看起来很完美，     但接下来我们再加上点需求：我们要“把大象拿出来，把长颈鹿装进去”",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://aimingoo.github.io"
    }
}
    </script>

    <script type="text/javascript" src="shared/ghost-url.js?v=8444992c76"></script>
<script type="text/javascript">
ghost.init({
	clientId: "ghost-frontend",
	clientSecret: "cb6d9de116b8"
});
</script>
    <meta name="generator" content="Ghost 0.11">
    <link rel="alternate" type="application/rss+xml" title="Aimingoo's Blog" href="rss/index.rss">
</head>

<body class="post-template tag-javascript tag-erlang tag-lisp tag-yu-yan tag-delphi nav-closed" data-spy="scroll" data-target="#tocScrollspy">

    <div class="site-wrapper">


        


<script type="text/javascript" author="aimingoo" src="assets/js/author-switcher.js?v=8444992c76"></script>

<header class="main-header">
    <nav class="container main-nav clearfix">
        <div class="main-nav-title pull-left">
            <script>
            var titleTextInBody = '<a class="blog-title" href="index.html">Aimingoo&#x27;s Blog</a>';
            var theAuthor = {slug: 'aimingoo', url: '/author/aimingoo/'};
            if (theAuthor.slug == 'joyxhy') {
                titleTextInBody = '<' + 'a class="blog-title" hr' + 'ef="' + theAuthor.url + '">麦秸的垛</a>';
            }
            document.writeln(titleTextInBody);
            </script>
        </div>
            <div class="nav pull-right">
    <ul>
            <li class="nav-" role="presentation"><a href="index.html">首页</a></li>
            <li class="nav-" role="presentation"><a href="archives-post/">历史</a></li>
            <li class="nav-" role="presentation"><a href="about.html">关于</a></li>
    </ul>
</div>

    </nav>
</header>

<main id="container" class="container" role="main">
    <div id="content" class="content col-sm-12 col-md-8 col-lg-8">
        <article class="post tag-javascript tag-erlang tag-lisp tag-yu-yan tag-delphi">
            <header class="post-header">
                <h1 class="post-title"><a href="1-137.html">表面的简洁</a></h1>
                <section class="post-meta">
                    <span class="post-meta-item">
                        <i class="fa fa-user"></i>
                        <a href="author/aimingoo/">aimingoo</a>
                    </span>
                    <span class="post-meta-item">
                        <i class="fa fa-clock-o"></i>
                        <time class="post-date" datetime="2009-04-22">8 years ago</time>
                        <time class="post-date" datetime="2009-04-22">(2009-04-22)</time>
                    </span>
                    <span class="post-meta-item post-meta-tags">
                        <i class="fa fa-tag"></i>
                        <a href="tag/javascript/">Javascript</a>, <a href="tag/erlang/">erlang</a>, <a href="tag/lisp/">lisp</a>, <a href="tag/yu-yan/">语言</a>, <a href="tag/delphi/">delphi</a>
                    </span>
                    <span class="post-meta-item pull-right">
                        
                    </span>
                </section>
            </header>

            <section class="post-content">
                <p>   </p>

<div style="border:1px dashed green; font-size:16px">  

**本文刊发在《程序员》杂志09年第二期上。是讨论函数式语言基本性质和发展方向的一篇文章。 **  

</div>  

<p>   </p>

<pre style="background-color:rgb(255,255,255)"><span style="font-family:Arial,宋体; font-size:16px"><big>**表面的简洁**</big></span></pre>  

<p>一、把大象装进冰箱    </p>

<p>＝＝＝＝＝    </p>

<p>　　在命令式语言（当然我们可以确指为C、Delphi、Java或C#等等）中，初学者的第一    </p>

<p>个疑难便是这样的代码（*注1）：    </p>

<p>　　X=X+1    </p>

<p>　　为什么？因为在数学概念中，上述等式是不能成立的。这种表达式是计算机的思维逻    </p>

<p>辑：当它运算上述表达式（或语句）时，X被作为暂存单元——例如冰箱。为了让冰箱产    </p>

<p>生变化，比如解决“把大象装进冰箱”这样的问题，我们需要如下三步：    </p>

<p>　　把冰箱门打开，把大象放进去，把冰箱门关上    </p>

<p><img src="content/images/bkImages/0_1331547245npif-9.gif" alt="" title="">    </p>

<p>（图1：“把大象装进冰箱”的问题）    </p>

<p>　　因为我们有两只手来分别负责拉住冰箱门和大象，所以整个操作过程看起来很完美，    </p>

<p>但接下来我们再加上点需求：我们要“把大象拿出来，把长颈鹿装进去”，怎么办？是的，    </p>

<p>应该这样：    </p>

<p>　　<strong>把冰箱门打开，把大象拿出来，把长颈鹿装进去，把冰箱门关上。</strong>    </p>

<p>　　可惜长颈鹿有腿有思想，所以问题将会出在我们把大象拿出来的那一时刻：长颈鹿跑    </p>

<p>掉了。为此，我们必须做很多的防护措施，例如先锁住长颈鹿，再锁住大象，以及在整个    </p>

<p>过程中，保证冰箱门不会自动关上或打开……而代码：    </p>

<p>　　X=X+1    </p>

<p>的执行过程与此类似：当CPU开始存取X这个位置时，它只能在“当前X”与“下一次X”    </p>

<p>之间选择二者之一。当多个线程（或多个CPU）开始存取X这个位置时，如果我们希望得    </p>

<p>到相同的X值，那么我们就得在X操作过程中采取象上面一样的防护措施：加一个锁。以    </p>

<p>保证要求所有线程都取完了这个“当前X”值，才会被切换到“下一次X”值。    </p>

<p>　　由于这个限制，一旦多个线程都排着队来看看这个X的美妙身形，整个队列就全都慢    </p>

<p>下来了。    </p>

<p>　　解决这个问题的办法其实很简单：只要X可见，我们就永远不修改这个X。而这，就    </p>

<p>是函数式应对大象问题的方法：如果冰箱里放着大象，就永远不要试图放长颈鹿。所以在    </p>

<p>函数式语言Erlang中的变量一旦赋值，就不能再修改。    </p>

<p>　　云风曾在SD2C 2007大会上说：解决问题的最好方法，就是不解决它。这个观点深得    </p>

<p>函数式的精髓。    </p>

<p>二、帽子戏法的关键，在于至少多一顶帽子    </p>

<p>＝＝＝＝＝    </p>

<p>　　杂技中的一种常见帽子戏法，是很多人围成一圈或排成一排然后飞速地传送手中的帽    </p>

<p>子。这如果是一个人来表演，那么应该是左右手各一顶帽子，而多出的一顶则总在头上。　　     </p>

<p><img src="content/images/bkImages/0_1331547260r2b1-9.gif" alt="" title="">    </p>

<p>（图2：帽子戏法）    </p>

<p>　　所以，关键在于至少要多出一顶帽子。正因为多出来这个帽子，所以我们看到杂技师    </p>

<p>在我们面前构建了一个往复不休的循环。事实上程序设计里的“循环”也存在完全相同的    </p>

<p>问题：我们至少需要一个变量来保存迭代中的计数，而且这个变量必须是可以修改的(*注    </p>

<p>2)。然而这一要求既是玩转“帽子戏法”的必要条件，却又与我们上面讲过的“不修改变    </p>

<p>量”的原则相违背。    </p>

<p>　　函数式如何解决这个问题呢？    </p>

<p>　　其实答案还是相同的答案：至少多一顶帽子。只不过，帽子不一定要放在头上，我们    </p>

<p>可以把它放在传递的过程中——例如空中——就可以了。要知道，让杂技师用同样的方法    </p>

<p>来掷苹果，那多出来的一个就总是在空中了。    </p>

<p>　　在函数式中，我们如果要构建一个循环，那么可以使用函数递归来实现。这上述控制    </p>

<p>循环过程的变量，则可以把它放在函数形式参数表——这种类似“空中”的地方。与“空    </p>

<p>中”相同的是，我们在静态看函数时，那是参数表；而运行中时，它传入实参。    </p>

<p>　　然而帽子戏法的表演者并没有三只手或更多只手，被循环帽子增加的时候，杂技师除    </p>

<p>了加快速度之外，保证一个简单的原则也是极其重要的：总是从帽子队列的最末端取到下    </p>

<p>一只帽子。这一原则保证了可以容纳更多帽子，而又不会少处理任何一个。同样的，递归    </p>

<p>是消耗栈的，为了使栈空间不爆炸，解决的方法就是在最后一行代码上调用递归，即尾递    </p>

<p>归。因为尾递归的存在，函数最末的调用就可以被优先为一行不消耗栈的跳转指令，就像    </p>

<p>帽子戏法的杂技师从帽子队列上直接取走轮转到手边的帽子一样。    </p>

<p>　　最后，对于一个函数来说，如果它只返回值而不修改函数外的任何东西，那么这个函    </p>

<p>数就是安全的，它等价于它返回的这个值——如前所述的，这个值一旦有效（运算出结果    </p>

<p>并传出），就不再变更。所以函数式中的函数调用，可以等价于一个表达式中运算的值。    </p>

<p>　　如同函数调用，函数的递归也只返回值，所以也等价于一个表达式中运算的值。再进    </p>

<p>一步的推论，递归实际上等效于循环求值。    </p>

<p>　　复杂的表象下，总会有一个简单的原则。万人的与一个人的帽子戏法，其原则是一样    </p>

<p>地：至少多一顶帽子，放在头上，或是空中。    </p>

<p>三、计算机其实不认得"hello"    </p>

<p>＝＝＝＝＝    </p>

<p>　　32位的unicode，以及128位的GUID等等，都直接与我们现在或将来的存储单位以及    </p>

<p>运算的通道大小有关。事实上即使我们有128位机器，我们也只打算在这样的通路上传送    </p>

<p>一个字符"h"——而不是字符串"hello"。从更为准确的角度来说，事实上计算机也不认得字    </p>

<p>符"h"，而只认得数字0x68。同样的，它也不认得所谓的“真假(true/false)”，而只认得数字    </p>

<p>的1/0。    </p>

<p><img src="content/images/bkImages/0_1331547334RXpX-9.gif" alt="" title="">    </p>

<p>（图3：图灵机的概念图）  </p>

<p>　　我们编程的本质，其实不过是在求值一些数字而已。只是最终我们在自然语义上把这    </p>

<p>些数字的一个连续或非连续的集合认为是布尔值、字符串、数组或对象。当我们认识到运    </p>

<p>算求值的结果无非是数值，而表达形式又无非是连续或非连续时，我们就得到了基本的数    </p>

<p>据抽象单元：值、值系列。再加上我们前面讲到的执行体（函数），我们就得到了整个函数    </p>

<p>式语言的鼻祖——LISP——的基本运算模型：    </p>

<p>　　(+ Xn)    </p>

<p>　　其中，“( )”表明一个值系列（表），而“+”在这里指代某种运算，Xn表明值（或值    </p>

<p>系列）。整个的表返回一个值，因此也可以将“整个的表（通常这里称为表达式）”等义为    </p>

<p>一个值。任何的一个运算，最终输出的仍然只是一个或一系列数字，它被显示在屏幕上，    </p>

<p>便成了文本；放在内存中，便成了数据。    </p>

<p>　　当然，现实是这样的机器最终从科学领域走向了民用，在PC（个人计算机）普及的现    </p>

<p>在，我们也需要让类似LISP这样的——绝对正确而又绝对非人性的——语言变得亲切一    </p>

<p>些。于是稍微复杂而有用一点的函数式语言，例如Erlang，通过丰富了上述的基本运算模    </p>

<p>型来使我们的视觉愉悦，或是在讨论它的代码时显得神经（略为）正常一些：    </p>

<table border="1" cellspacing="0" cellpadding="0" width="576">  
<tbody>  
<tr>  
<td valign="top">  
<p align="center">**类型**  

</p></td>  
<td valign="top">  

**示例**  

</td>  
</tr>  
<tr>  
<td valign="top">  

值  

</td>  
<td valign="top">  

atom,integer/float,...  

</td>  
</tr>  
<tr>  
<td valign="top">  

值系列  

</td>  
<td valign="top">  

list(不定长的表，一般非连续存储)  

tuple(定长的，一般连续存储)  

</td>  
</tr>  
<tr>  
<td valign="top">  

运算  

</td>  
<td valign="top">  

函数。特定函数包括：if..end，case..end等。  

</td>  
</tr>  
</tbody>  
</table>  

<p></p>  

<p>（表一：以Erlang为例的、简单的类型抽象）    </p>

<p>　　而我们逆推一份具体的Erlang代码，其实仍然可以表达为上述的(+ Xn)。例如我们可    </p>

<p>以在Erlang代码在编译阶段使用解析树（Abstract Form）中看到这样的抽象代码（abstract     </p>

<p>code）：    </p>

<p></p><pre name="code" class="plain">　　[{abstract<em>code, <br>
　　  {raw</em>abstract_v1, [{attribute,1,file,{"./simplest.erl",1}}, <br>
       {attribute,1,module,simplest}, <br>
       {function,3,test,0, <br>
　　      [{clause,3,[],[],[{atom,4|...}]}] <br>
　　    }, <br>
　　    {eof,1}] <br>
　　  } <br>
　　}]</pre>　　无论是从形式，还是从实质来看，这种解析树（在erlang执行中将会按照解析树来生    

<p>成语法树并执行）与LISP语言的基本原则都是一致的。    </p>

<p>四、从“函数等义于值”到“函数是值”    </p>

<p>＝＝＝＝＝    </p>

<p>　　现在，JavaScript语言被更为深入的挖掘并渐渐了解到它的函数式语言本质，而类似    </p>

<p>Erlang这样的“天生伤害人的视力”的语言也移步前台。这些语言的努力，使我们终于看    </p>

<p>到一个属于函数式语言的时代的曙光。在黎明之前的黑暗中，函数式以它诸多的、最不可    </p>

<p>思议的特性迷惘着程序员的目光。连它最基本的概念说明，也如同玄学家的呓语：如同数    </p>

<p>学函数是集合A（称为定义域）中成员到集合B（称为值域）中成员的映射，函数式语言    </p>

<p>就是通过数学函数的定义、应用的说明和求值完成运算过程的。    </p>

<p>　　类似于这种等同于“什么也没说”的解释，其实的确是在阐述函数式语言的精髓。为    </p>

<p>了减轻你的痛苦（但绝非轻视你的智商），我通常换个说法来陈述它们：如果表达式“1+1=2”    </p>

<p>中的“+”被理解为求值函数，那么所谓函数式语言，就是通过连续表达式运算求值的语言；    </p>

<p>既然上面的表达式可以算出结果“=2”，那么函数式语言自然也可以通过不停地求值找到问    </p>

<p>题的答案。    </p>

<p>　　首先，在函数式语言中，函数只表明一个运算过程，并产生一个运算结果。这与表达    </p>

<p>式中的运算符具有完全相同的性质——所以事实上一个函数式语言中，表达式的运算符被    </p>

<p>实现为一个函数。例如erlang的核心模块中，可以导出类似这样的函数：    </p>

<table border="1" cellspacing="0" cellpadding="0" width="572">  
<tbody>  
<tr>  
<td valign="top">  

**函数名/参数个数**  

</td>  
<td valign="top">  

**函数名/参数个数**  

</td>  
<td valign="top">  

**函数名/参数个数**  

</td>  
</tr>  
<tr>  
<td valign="top">  

'!'/2  

</td>  
<td valign="top">  

'+'/1  

</td>  
<td valign="top">  

'-'/1  

</td>  
</tr>  
<tr>  
<td valign="top">  

'*'/2  

</td>  
<td valign="top">  

'+'/2  

</td>  
<td valign="top">  

'-'/2  

</td>  
</tr>  
<tr>  
<td valign="top">  

   

</td>  
<td valign="top">  

'++'/2  

</td>  
<td valign="top">  

'--'/2  

</td>  
</tr>  
</tbody>  
</table>  

<p>（表二：Erlang中的运算符其实对应于内核函数－部分举例）    </p>

<p>　　所以，函数式语言的本质是表达式/函数的“连续求值”。既然我们的输出或存储最终    </p>

<p>只是在关心“值”，那么显然连续求值的结果就可以直接作为他们的输入。如果把输出终端    </p>

<p>或存储看成接受输入的设备，那么他也相当于一个函数；如果一台计算设备只对外界表达    </p>

<p>为一个或一系列输出，并接受来自其他类似设备的输入，那么计算设备本身也可以视为一    </p>

<p>个函数……    </p>

<p>　　我们将这个过程放大，其实网络可以是函数式的。这个就是著名的语用网，它的理论    </p>

<p>基础是petri网论（Petri nets theory）。而事实上，作为计算模型来理解，它与函数式语言是    </p>

<p>相似、等价的（*注3）。    </p>

<p><img src="content/images/bkImages/0_1331547377Z9tD-9.gif" alt="" title="">    </p>

<p>图4：perti网的“库所变换”    </p>

<p>　　函数式语言通过函数实现了三个基本的运算逻辑（顺序、分支与循环），因此它与我们    </p>

<p>常用的命令式语言是等价的(*注4)。但是由于存在存储问题，所以命令式语言是时序相关    </p>

<p>的——即有存取某个存储单元的先后问题。而函数式语言由于“把大象装进冰箱”之后就    </p>

<p>再也不可更改，因此变得时序无关。    </p>

<p>　　以上述的petri网的例子来讲，由于时序无关，所以图左侧的“库所（圆圈）”中的两    </p>

<p>个“消息（黑点）”分解成右侧的两个库所来处理时，其转换的代价为0（无锁），而这个    </p>

<p>过程应用在多核机器或分布式网络上时，效率却提高了一倍。    </p>

<p>　　更深层次地思考这个问题，由于在计算机系统中函数本身仍然是以数据形式存储的，    </p>

<p>所以函数事实上也是“被运算的对象”和“运算结果”。函数的这种特性被称为高阶函数。    </p>

<p>“函数等义于值”是函数式的基础，而“函数是值”，则是高阶函数的基础。    </p>

<p><img src="content/images/bkImages/0_1331547559DyZy-9.gif" alt="" title="">    </p>

<p>图5：JavaScript统一语言范型的基本模型（*注5）    </p>

<p>　　当“函数是值”时，我们可以把一个函数传递到另一个地方去运算，而其运算结果仍    </p>

<p>然是值，所以可以把一个等义的结果再传回来。注意这一过程，就是分布运算的实质，所    </p>

<p>以，函数式在本质上、天生地就是支持分布运算的。无论我们是将“一段函数式代码”所    </p>

<p>表达的整个运算过程分解成何种形式，并分布在何种复杂的运算环境或网络环境中，只要    </p>

<p>最终在逻辑上它能得到一个值序列和一个运算，就能够成为更大范围的分布网络中的一个    </p>

<p>结点。    </p>

<p>　　而这，就是整个计算世界的全部（注6）：(symbol)。    </p>

<p><span style="font-size:13px">＝＝＝＝＝＝＝＝＝＝    </span></p>

<p>　　注1：《Erlang程序设计》中，作者以这个例子为起始，来讲述Erlang变量的单一赋值。    </p>

<p>　　注2：参见《结构程序设计》，讨论“如何刻画计算的进展”时，作者E.W.Dijkstra说：    </p>

<p>（程序）如果含有循环语句，仅用语法指示器就不能描述计算的进展了……（而应该）引    </p>

<p>进一个“动态指示器”毫不含糊地累计相应的现行循环的序数……因为，语法指示器无法    </p>

<p>充当这种坐标系统的一个组成成分。    </p>

<p>　　注3："Implementing Coloured Petri Nets Using a Functional Programming Language" at     </p>

<p><a href="http://portal.acm.org/citation.cfm?id=993039%EF%BC%8Cand">http://portal.acm.org/citation.cfm?id=993039，and</a> Functional Nets at <a href="http://lamp.epfl.ch/fn/">http://lamp.epfl.ch/fn/</a>    </p>

<p>　　注4：不同范型的计算机语言之间等价问题，可以归结到图灵等价这个命题上，这意    </p>

<p>味着该运算系统或模型能够执行任何复杂程度的、图灵机可完成的数学运算。2007年，Alex     </p>

<p>Smith证明了Wolfram提出了最小的“2,3图灵机（两种颜色，三种状态）”模型是最小完    </p>

<p>备的图灵等价系统。    </p>

<p>　　注5：这个统一过程用到了多项与函数式相关的基本设定：函数是执行体、函数等义    </p>

<p>于值、函数是值。    </p>

<p>　　注6：与“(+ Xn)”比较，这个表达式认为“运算 +”——也就是某个函数——其实也    </p>

<p>是值，因此它也是“值系列”Xn中的一个部分。于是，当由自然语义中的symbol来指代    </p>

<p>Xn时，整个表达式就变成了：(symbol)。建议阅读作者的其它两篇文章：    </p>

<p>　　《从表达式到变量：一行scheme代码之所见》    </p>

<p>　　<a href="http://blog.csdn.net/aimingoo/archive/2007/02/12/1508118.aspx">http://blog.csdn.net/aimingoo/archive/2007/02/12/1508118.aspx</a>    </p>

<p>　　《从表达式到函数：表面的简洁》    </p>

<p>　　<a href="http://blog.csdn.net/aimingoo/archive/2007/10/08/1815379.aspx">http://blog.csdn.net/aimingoo/archive/2007/10/08/1815379.aspx</a>    </p>
            </section>
<!-- removed by aimingoo
            <footer class="post-footer">
                {-{!> "post_author"}}
            </footer>
-->
        </article>

        <aside class="post-nav">
            <span class="post-nav-prev">
                上一篇
                <a href="1-136.html">
                    饭桶英雄
                </a>
            </span>

            <span class="post-nav-next">
                <a href="1-138.html">
                    本来面目——大教堂、集市，与作坊
                </a>
                下一篇
            </span>
        </aside>

        <section class="post comments">
<div id="gitment-root"></div>

<link rel="stylesheet" type="text/css" href="assets/css/gitment.default.css?v=8444992c76">
<script src="assets/js/gitment.browser.js?v=8444992c76"></script>

<script type="text/javascript">
	var SHORT_ID = function(url) { return url.replace(/\?.*$/, '').replace(/^.*\/|.html$/g, '') };
	var gitment = new Gitment({
	  id: SHORT_ID(location.href),
	  owner: 'aimingoo',
	  repo: 'aimingoo.github.io',
	  oauth: { client_id: 'c1285a991ba7db5c395a' }
	});
	gitment.render('gitment-root');
</script>
<noscript>Please enable JavaScript to view theses comments.</noscript>
</section>    </div>
    <div id="sidebar" class="sidebar col-md-4 col-lg-4">

            <div class="widget widget-profile">
        <div class="widget-profile-cover overlay no-cover"></div>
        <div class="widget-profile-header">
            <a class="widget-profile-logo" href="author/aimingoo/">
                <img src="content/images/2017/05/-----2017-05-06-12-23-58.png" alt="Aimingoo's Blog">
            </a>
        </div>
        <span class="widget-profile-title label label-xlg label-minty arrowed-in arrowed-in-right">aimingoo</span>
        <hr>
        <p class="widget-profile-desc">
                I'm here.
        </p>
        <hr>
        <!-- replaced by aimingoo -->
        <script type="text/javascript" src="profile-aimingoo"></script>
    </div>


<!-- replaced by aimingoo
    {-{> "tag_cloud"}}
-->
        <script type="text/javascript" author="aimingoo" src="tag-cloud"></script>

        <div class="widget widget-toc">
    <div class="widget-title">
        <div class="widget-title-meta">
            <i class="fa fa-list-ul"></i> 
            <span class="title-meta-word">文章目录</span>
        </div>
    </div>
    <nav id="tocScrollspy">
        <ul id="toc" class="toc"></ul>
    </nav>
</div>
</div>
</main>


        <footer class="site-footer clearfix">
            <div class="footer-meta container">
                <section class="copyright"><a href="index.html">Aimingoo's Blog</a> © 2017</section>
                <section class="poweredby">Proudly published with <a href="https://ghost.org">Ghost</a>, Theme <a href="https://github.com/xiaoluoboding/kaldorei">Kaldorei</a></section>
            </div>
        </footer>

    </div>

    <div id="backTop" class="backTop">
        <button class="btn btn-inverse">
            <i class="fa fa-chevron-up"></i>
        </button>
    </div>

    <script type="text/javascript" src="assets/js/jquery-1.12.0.min.js?v=8444992c76"></script>
    

    <script type="text/javascript" src="assets/js/jquery.fitvids.js?v=8444992c76"></script>
    <script type="text/javascript" src="assets/js/index.js?v=8444992c76"></script>
    <script type="text/javascript" src="assets/plugins/bootstrap-3.3.5/js/bootstrap.min.js?v=8444992c76"></script>
    <script type="text/javascript" src="assets/plugins/highlight-9.1.0/highlight.pack.js?v=8444992c76"></script>
    <script type="text/javascript" src="assets/plugins/jquery-toc-0.3.5/jquery.toc.js?v=8444992c76"></script>
    <script type="text/javascript" src="assets/plugins/velocity-1.2.3/velocity.min.js?v=8444992c76"></script>
    <script type="text/javascript" src="assets/plugins/velocity-1.2.3/velocity.ui.min.js?v=8444992c76"></script>
    <script type="text/javascript" src="assets/plugins/anijs-0.9.3/anijs-min.js?v=8444992c76"></script>
    <script type="text/javascript" src="assets/plugins/anijs-0.9.3/anijs-helper-scrollreveal-min.js?v=8444992c76"></script>
    <script type="text/javascript" src="assets/plugins/github-repo-jquery-widget/jquery.githubRepoWidget.min.js?v=8444992c76"></script>
    <script type="text/javascript" src="assets/plugins/fancybox-2.1.5/jquery.fancybox.pack.js?v=8444992c76"></script>
</body>

